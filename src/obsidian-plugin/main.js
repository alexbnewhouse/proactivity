/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ProactivityPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/proactive-view.ts
var import_obsidian2 = require("obsidian");

// src/api-client.ts
var import_obsidian = require("obsidian");
var ProactivityApiClient = class {
  constructor(settings) {
    this.settings = settings;
    this.baseUrl = settings.serverUrl || "http://localhost:3001";
  }
  updateSettings(settings) {
    this.settings = settings;
    this.baseUrl = settings.serverUrl || "http://localhost:3001";
  }
  /**
   * Make HTTP request with error handling
   */
  async makeRequest(endpoint, options = {}) {
    const url = `${this.baseUrl}/api${endpoint}`;
    const defaultOptions = {
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      },
      ...options
    };
    try {
      const response = await fetch(url, defaultOptions);
      const data = await response.json();
      if (!response.ok) {
        const error = data;
        throw new Error(error.message || `HTTP ${response.status}: ${response.statusText}`);
      }
      return data;
    } catch (error) {
      if (error instanceof TypeError && error.message.includes("fetch")) {
        throw new Error("Unable to connect to Proactivity server. Please check that the backend is running.");
      }
      throw error;
    }
  }
  /**
   * Test connection to backend
   */
  async testConnection() {
    try {
      const response = await fetch(`${this.baseUrl}/health`);
      return response.ok;
    } catch (error) {
      return false;
    }
  }
  /**
   * Get health status from backend
   */
  async getHealth() {
    return this.makeRequest("/health");
  }
  /**
   * Break down a task into ADHD-friendly micro-tasks
   */
  async breakdownTask(request) {
    return this.makeRequest("/tasks/breakdown", {
      method: "POST",
      body: JSON.stringify(request)
    });
  }
  /**
   * Get task suggestions based on current context
   */
  async getTaskSuggestions(energyLevel = "moderate", availableTime = 30, category) {
    const params = new URLSearchParams({
      energyLevel,
      availableTime: availableTime.toString()
    });
    if (category) {
      params.append("category", category);
    }
    return this.makeRequest(`/tasks/suggestions?${params}`);
  }
  /**
   * Start tracking a task
   */
  async startTask(taskId, estimatedDuration) {
    return this.makeRequest("/tasks/start", {
      method: "POST",
      body: JSON.stringify({
        taskId,
        estimatedDuration,
        userId: "obsidian_user"
        // Could be made configurable
      })
    });
  }
  /**
   * Mark task as completed
   */
  async completeTask(taskId, actualDuration, difficulty, notes) {
    return this.makeRequest("/tasks/complete", {
      method: "POST",
      body: JSON.stringify({
        taskId,
        actualDuration,
        difficulty,
        notes,
        userId: "obsidian_user"
      })
    });
  }
  /**
   * Get task templates for common dissertation activities
   */
  async getTaskTemplates() {
    return this.makeRequest("/tasks/templates");
  }
  /**
   * Update user energy level
   */
  async updateEnergyLevel(energyLevel) {
    return this.makeRequest("/users/energy-log", {
      method: "POST",
      body: JSON.stringify({
        energyLevel,
        timestamp: new Date().toISOString(),
        userId: "obsidian_user"
      })
    });
  }
  /**
   * Record user activity for pattern detection
   */
  async recordActivity(activityType, data) {
    return this.makeRequest("/patterns/detect", {
      method: "POST",
      body: JSON.stringify({
        type: activityType,
        data,
        timestamp: new Date().toISOString(),
        userId: "obsidian_user"
      })
    });
  }
  /**
   * Get ADHD patterns and insights
   */
  async getPatterns() {
    return this.makeRequest("/patterns/insights");
  }
  /**
   * Safe wrapper for API calls with user feedback
   */
  async safeApiCall(operation, fallback, errorMessage) {
    try {
      return await operation();
    } catch (error) {
      console.error("API call failed:", error);
      const message = errorMessage || "API request failed. Please check your connection and backend server.";
      new import_obsidian.Notice(`\u26A0\uFE0F ${message}`, 5e3);
      if (fallback !== void 0) {
        return fallback;
      }
      return void 0;
    }
  }
  /**
   * Convert task breakdown response to format expected by UI
   */
  static formatBreakdownForUI(response) {
    if (!response.success || !response.data) {
      throw new Error("Invalid breakdown response");
    }
    const { data } = response;
    return {
      motivation: `Great choice! I've broken this down into ${data.microTasks.length} manageable steps. \u{1F3AF}`,
      steps: data.microTasks.map((task, index) => ({
        id: task.id || `step_${index}`,
        title: task.title,
        description: task.description,
        estimatedMinutes: task.estimatedMinutes || 20,
        complexity: task.complexity || "simple",
        tips: task.motivationBooster ? [task.motivationBooster] : [],
        energyRequired: task.energyRequired || "moderate",
        executiveFunctionDemands: task.executiveFunctionDemands || [],
        tools: task.tools || [],
        completionCriteria: task.completionCriteria || "Step completed"
      })),
      totalEstimatedTime: data.totalEstimatedTime,
      strategy: data.breakdownStrategy,
      optimizations: data.adhdOptimizations
    };
  }
};

// src/proactive-view.ts
var VIEW_TYPE_PROACTIVITY = "proactivity-view";
var ProactivityView = class extends import_obsidian2.ItemView {
  constructor(leaf, settings, integrationService) {
    super(leaf);
    this.currentEnergyLevel = "moderate";
    this.todaysTasks = [];
    this.currentFocus = "";
    this.settings = settings;
    this.integrationService = integrationService;
    this.apiClient = new ProactivityApiClient(settings);
  }
  getViewType() {
    return VIEW_TYPE_PROACTIVITY;
  }
  getDisplayText() {
    return "Proactivity";
  }
  getIcon() {
    return "brain";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("proactivity-view");
    this.renderMainInterface(container);
    await this.loadTodaysTasks();
    if (this.settings.browserExtensionSync.enableSync) {
      this.startBrowserSync();
    }
  }
  async onClose() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
    }
  }
  renderMainInterface(container) {
    const header = container.createEl("div", { cls: "proactive-header" });
    const title = header.createEl("h2", { text: "Proactivity Assistant" });
    this.renderEnergySection(container);
    this.renderFocusSection(container);
    this.renderTaskDashboardSection(container);
    this.renderTaskSuggestionsSection(container);
    this.renderProgressSection(container);
    this.renderBrowserSyncSection(container);
    this.renderQuickActionsSection(container);
    this.renderADHDSupportSection(container);
  }
  renderEnergySection(container) {
    const energySection = container.createEl("div", { cls: "energy-section" });
    energySection.createEl("h3", { text: "\u26A1 Energy Level" });
    const energyDisplay = energySection.createEl("div", { cls: "energy-display" });
    const energyLevels = [
      { level: "high", emoji: "\u26A1", label: "High" },
      { level: "moderate", emoji: "\u{1F50B}", label: "Moderate" },
      { level: "low", emoji: "\u{1FAAB}", label: "Low" },
      { level: "depleted", emoji: "\u{1F634}", label: "Depleted" }
    ];
    energyLevels.forEach(({ level, emoji, label }) => {
      const button = energyDisplay.createEl("button", {
        cls: `energy-button ${this.currentEnergyLevel === level ? "active" : ""}`,
        text: `${emoji} ${label}`
      });
      button.onclick = async () => {
        await this.updateEnergyLevel(level);
        this.refreshEnergyDisplay();
      };
    });
    const recommendations = energySection.createEl("div", { cls: "energy-recommendations" });
    this.updateEnergyRecommendations(recommendations);
  }
  renderFocusSection(container) {
    const focusSection = container.createEl("div", { cls: "focus-section" });
    focusSection.createEl("h3", { text: "\u{1F3AF} Current Focus" });
    const focusInput = focusSection.createEl("input", {
      type: "text",
      placeholder: "What are you working on right now?",
      value: this.currentFocus,
      cls: "focus-input"
    });
    focusInput.addEventListener("change", (e) => {
      this.currentFocus = e.target.value;
      this.integrationService.updateCurrentFocus(this.currentFocus);
    });
    const timerSection = focusSection.createEl("div", { cls: "focus-timer" });
    const startButton = timerSection.createEl("button", {
      text: "\u25B6\uFE0F Start 25min Focus",
      cls: "mod-cta"
    });
    startButton.onclick = () => {
      this.startFocusTimer(25);
    };
  }
  renderTaskDashboardSection(container) {
    const dashboardSection = container.createEl("div", { cls: "task-dashboard-section" });
    dashboardSection.createEl("h3", { text: "\u{1F4CB} Task Dashboard" });
    const statsRow = dashboardSection.createEl("div", { cls: "stats-row" });
    const completedStat = statsRow.createEl("div", { cls: "stat-card completed" });
    completedStat.createEl("div", { cls: "stat-number", text: "0" });
    completedStat.createEl("div", { cls: "stat-label", text: "Completed" });
    const activeStat = statsRow.createEl("div", { cls: "stat-card active" });
    activeStat.createEl("div", { cls: "stat-number", text: "0" });
    activeStat.createEl("div", { cls: "stat-label", text: "Active" });
    const urgentStat = statsRow.createEl("div", { cls: "stat-card urgent" });
    urgentStat.createEl("div", { cls: "stat-number", text: "0" });
    urgentStat.createEl("div", { cls: "stat-label", text: "Urgent" });
    const inputSection = dashboardSection.createEl("div", { cls: "task-input-section" });
    const taskInput = inputSection.createEl("input", {
      cls: "task-input",
      placeholder: "Add a new task...",
      type: "text"
    });
    const addButton = inputSection.createEl("button", {
      cls: "add-task-btn",
      text: "+ Add"
    });
    const taskListContainer = dashboardSection.createEl("div", { cls: "task-list-container" });
    const taskList = taskListContainer.createEl("div", { cls: "task-list" });
    const addTask = () => {
      const taskText = taskInput.value.trim();
      if (taskText) {
        this.addNewTask(taskText, taskList);
        taskInput.value = "";
        this.updateTaskStats();
      }
    };
    addButton.addEventListener("click", addTask);
    taskInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        addTask();
      }
    });
    this.loadTasksFromVault(taskList);
    this.updateTaskStats();
  }
  async addNewTask(taskText, taskList) {
    const taskItem = taskList.createEl("div", { cls: "task-item" });
    const checkbox = taskItem.createEl("input", { type: "checkbox", cls: "task-checkbox" });
    const taskContent = taskItem.createEl("div", { cls: "task-content" });
    const taskTitle = taskContent.createEl("div", { cls: "task-title", text: taskText });
    const taskMeta = taskContent.createEl("div", { cls: "task-meta" });
    const priority = taskMeta.createEl("span", { cls: "task-priority", text: "Normal" });
    const timeEstimate = taskMeta.createEl("span", { cls: "task-time", text: "~25min" });
    const actions = taskItem.createEl("div", { cls: "task-actions" });
    const breakdownBtn = actions.createEl("button", { cls: "task-action-btn", text: "\u{1F528}" });
    const deleteBtn = actions.createEl("button", { cls: "task-action-btn delete", text: "\u{1F5D1}\uFE0F" });
    checkbox.addEventListener("change", () => {
      if (checkbox.checked) {
        taskItem.classList.add("completed");
        this.completeTask(taskText);
      } else {
        taskItem.classList.remove("completed");
      }
      this.updateTaskStats();
    });
    breakdownBtn.addEventListener("click", () => {
      this.breakdownTask(taskText);
    });
    deleteBtn.addEventListener("click", () => {
      taskItem.remove();
      this.updateTaskStats();
    });
    try {
      await this.integrationService.addTaskToVault(taskText);
    } catch (error) {
      console.error("Failed to add task to vault:", error);
    }
  }
  async loadTasksFromVault(taskList) {
    try {
      const tasks = await this.integrationService.getTodaysTasks();
      tasks.forEach((task) => {
        this.renderExistingTask(task, taskList);
      });
    } catch (error) {
      console.error("Failed to load tasks from vault:", error);
    }
  }
  renderExistingTask(task, taskList) {
    const taskItem = taskList.createEl("div", { cls: "task-item" });
    if (task.completed)
      taskItem.classList.add("completed");
    const checkbox = taskItem.createEl("input", {
      type: "checkbox",
      cls: "task-checkbox"
    });
    checkbox.checked = task.completed;
    const taskContent = taskItem.createEl("div", { cls: "task-content" });
    const taskTitle = taskContent.createEl("div", { cls: "task-title", text: task.title });
    const taskMeta = taskContent.createEl("div", { cls: "task-meta" });
    taskMeta.createEl("span", { cls: "task-priority", text: task.priority || "Normal" });
    taskMeta.createEl("span", { cls: "task-time", text: `~${task.estimatedMinutes || 25}min` });
    const actions = taskItem.createEl("div", { cls: "task-actions" });
    const breakdownBtn = actions.createEl("button", { cls: "task-action-btn", text: "\u{1F528}" });
    const deleteBtn = actions.createEl("button", { cls: "task-action-btn delete", text: "\u{1F5D1}\uFE0F" });
    checkbox.addEventListener("change", () => {
      if (checkbox.checked) {
        taskItem.classList.add("completed");
        this.completeTask(task.title);
      } else {
        taskItem.classList.remove("completed");
      }
      this.updateTaskStats();
    });
    breakdownBtn.addEventListener("click", () => {
      this.breakdownTask(task.title);
    });
    deleteBtn.addEventListener("click", () => {
      taskItem.remove();
      this.updateTaskStats();
    });
  }
  updateTaskStats() {
    const taskItems = this.containerEl.querySelectorAll(".task-item");
    const completedTasks = this.containerEl.querySelectorAll(".task-item.completed");
    const activeTasks = taskItems.length - completedTasks.length;
    const urgentTasks = this.containerEl.querySelectorAll(".task-item .task-priority").length;
    const statCards = this.containerEl.querySelectorAll(".stat-card");
    if (statCards.length >= 3) {
      statCards[0].querySelector(".stat-number").textContent = completedTasks.length.toString();
      statCards[1].querySelector(".stat-number").textContent = activeTasks.toString();
      statCards[2].querySelector(".stat-number").textContent = "0";
    }
  }
  async completeTask(taskTitle) {
    try {
      await this.integrationService.completeTask(taskTitle);
      new import_obsidian2.Notice(`\u2705 Task completed: ${taskTitle}`);
    } catch (error) {
      console.error("Failed to complete task:", error);
    }
  }
  async breakdownTask(taskTitle) {
    try {
      const breakdown = await this.integrationService.breakdownTask(taskTitle, {
        energyLevel: this.currentEnergyLevel,
        depth: 2
      });
      if (breakdown && breakdown.steps) {
        new import_obsidian2.Notice(`\u{1F528} Task broken down into ${breakdown.steps.length} steps`);
      }
    } catch (error) {
      console.error("Failed to breakdown task:", error);
      new import_obsidian2.Notice("Failed to breakdown task. Check your OpenAI API key.");
    }
  }
  renderTaskSuggestionsSection(container) {
    const tasksSection = container.createEl("div", { cls: "tasks-section" });
    tasksSection.createEl("h3", { text: "\u{1F4DD} Smart Task Suggestions" });
    const tasksContainer = tasksSection.createEl("div", { cls: "tasks-container" });
    const refreshButton = tasksSection.createEl("button", {
      text: "\u{1F504} Get New Suggestions",
      cls: "refresh-tasks-btn"
    });
    refreshButton.onclick = () => {
      this.refreshTaskSuggestions();
    };
    this.renderTaskList(tasksContainer);
  }
  renderBrowserSyncSection(container) {
    const syncSection = container.createEl("div", { cls: "browser-sync-section" });
    syncSection.createEl("h3", { text: "\u{1F504} Browser Extension Sync" });
    const statusDiv = syncSection.createEl("div", { cls: "sync-status" });
    const statusIcon = statusDiv.createEl("span", { cls: "sync-status-icon", text: "\u{1F7E1}" });
    const statusText = statusDiv.createEl("span", { cls: "sync-status-text", text: "Checking sync status..." });
    const infoBox = syncSection.createEl("div", { cls: "sync-info-box" });
    const infoTitle = infoBox.createEl("div", { cls: "sync-info-title", text: "How Browser Sync Works" });
    const infoList = infoBox.createEl("ul", { cls: "sync-info-list" });
    infoList.createEl("li", { text: "\u2705 Tasks sync automatically between Obsidian and browser extension" });
    infoList.createEl("li", { text: "\u{1F50B} Energy levels are shared across both platforms" });
    infoList.createEl("li", { text: "\u23F1\uFE0F Focus sessions sync in real-time" });
    infoList.createEl("li", { text: "\u{1F3AF} Enforcement settings apply to both apps" });
    const syncButton = syncSection.createEl("button", {
      cls: "sync-button",
      text: "\u{1F504} Sync Now"
    });
    const lastSyncDiv = syncSection.createEl("div", { cls: "last-sync" });
    lastSyncDiv.createEl("span", {
      cls: "last-sync-text",
      text: "Last sync: Never"
    });
    syncButton.addEventListener("click", async () => {
      syncButton.textContent = "\u{1F504} Syncing...";
      syncButton.disabled = true;
      try {
        await this.performBrowserSync();
        statusIcon.textContent = "\u{1F7E2}";
        statusText.textContent = "Sync successful";
        lastSyncDiv.querySelector(".last-sync-text").textContent = `Last sync: ${new Date().toLocaleTimeString()}`;
        new import_obsidian2.Notice("\u2705 Browser extension sync completed");
      } catch (error) {
        statusIcon.textContent = "\u{1F534}";
        statusText.textContent = "Sync failed";
        console.error("Manual sync failed:", error);
        new import_obsidian2.Notice("\u274C Sync failed. Check console for details.");
      } finally {
        syncButton.textContent = "\u{1F504} Sync Now";
        syncButton.disabled = false;
      }
    });
    this.checkSyncStatus(statusIcon, statusText, lastSyncDiv);
  }
  async performBrowserSync() {
    const obsidianData = {
      tasks: await this.integrationService.getTodaysTasks(),
      energyLevel: this.currentEnergyLevel,
      timestamp: Date.now(),
      source: "obsidian"
    };
    try {
      localStorage.setItem("proactivity-obsidian-sync", JSON.stringify(obsidianData));
      const browserData = localStorage.getItem("proactivity-browser-sync");
      if (browserData) {
        const parsed = JSON.parse(browserData);
        console.log("Received data from browser extension:", parsed);
        if (parsed.timestamp > obsidianData.timestamp - 6e4) {
          console.log("Browser extension data is recent, considering merge");
        }
      }
      if (this.apiClient) {
        await this.apiClient.updateEnergyLevel(this.currentEnergyLevel);
      }
      console.log("Browser sync completed successfully");
    } catch (error) {
      console.error("Browser sync failed:", error);
      throw error;
    }
  }
  startBrowserSync() {
    console.log("Starting browser extension sync in ProactivityView...");
    this.readBrowserExtensionData();
    const syncIntervalMs = this.settings.browserExtensionSync.syncInterval * 60 * 1e3;
    this.syncInterval = setInterval(() => {
      this.readBrowserExtensionData();
    }, syncIntervalMs);
  }
  async readBrowserExtensionData() {
    try {
      const browserData = localStorage.getItem("proactivity-browser-sync");
      if (browserData) {
        const parsed = JSON.parse(browserData);
        if (parsed.timestamp && Date.now() - parsed.timestamp < 3e5) {
          console.log("Reading recent data from browser extension:", parsed);
          if (parsed.tasks && Array.isArray(parsed.tasks)) {
            for (const browserTask of parsed.tasks) {
              if (!browserTask.id || browserTask.source === "obsidian")
                continue;
              try {
                await this.integrationService.addTaskToVault(browserTask.title || browserTask.text, browserTask.priority);
                console.log(`Added task from browser: ${browserTask.title}`);
              } catch (error) {
                console.error("Failed to add browser task to vault:", error);
              }
            }
            this.loadTasksFromVault(this.containerEl.querySelector(".task-list"));
            this.updateTaskStats();
          }
          if (parsed.energyLevel && parsed.energyLevel !== this.currentEnergyLevel) {
            this.currentEnergyLevel = parsed.energyLevel;
            console.log(`Updated energy level from browser: ${parsed.energyLevel}`);
          }
        }
      }
    } catch (error) {
      console.error("Failed to read browser extension data:", error);
    }
  }
  checkSyncStatus(statusIcon, statusText, lastSyncDiv) {
    try {
      const syncData = localStorage.getItem("proactivity-obsidian-sync");
      if (syncData) {
        const parsed = JSON.parse(syncData);
        const lastSync = new Date(parsed.timestamp);
        const minutesAgo = Math.floor((Date.now() - parsed.timestamp) / (1e3 * 60));
        if (minutesAgo < 5) {
          statusIcon.textContent = "\u{1F7E2}";
          statusText.textContent = "Recently synced";
        } else if (minutesAgo < 30) {
          statusIcon.textContent = "\u{1F7E1}";
          statusText.textContent = "Sync available";
        } else {
          statusIcon.textContent = "\u{1F7E0}";
          statusText.textContent = "Sync recommended";
        }
        lastSyncDiv.querySelector(".last-sync-text").textContent = `Last sync: ${lastSync.toLocaleTimeString()}`;
      } else {
        statusIcon.textContent = "\u{1F534}";
        statusText.textContent = "Never synced";
        lastSyncDiv.querySelector(".last-sync-text").textContent = "Last sync: Never";
      }
    } catch (error) {
      statusIcon.textContent = "\u2753";
      statusText.textContent = "Sync status unknown";
      console.error("Failed to check sync status:", error);
    }
  }
  renderProgressSection(container) {
    const progressSection = container.createEl("div", { cls: "progress-section" });
    progressSection.createEl("h3", { text: "\u{1F4CA} Today's Progress" });
    const progressBar = progressSection.createEl("div", { cls: "progress-bar" });
    const progressFill = progressBar.createEl("div", { cls: "progress-fill" });
    const stats = progressSection.createEl("div", { cls: "progress-stats" });
    stats.createEl("div", { cls: "stat-item", text: "\u{1F3AF} 0 tasks completed" });
    stats.createEl("div", { cls: "stat-item", text: "\u23F1\uFE0F 0 minutes focused" });
    stats.createEl("div", { cls: "stat-item", text: "\u{1F4DD} 0 words written" });
    const celebrateButton = progressSection.createEl("button", {
      text: "\u{1F389} Celebrate Progress",
      cls: "celebrate-btn"
    });
    celebrateButton.onclick = () => {
      this.celebrateProgress();
    };
  }
  renderQuickActionsSection(container) {
    const actionsSection = container.createEl("div", { cls: "quick-actions-section" });
    actionsSection.createEl("h3", { text: "\u26A1 Quick Actions" });
    const actionsGrid = actionsSection.createEl("div", { cls: "actions-grid" });
    const actions = [
      {
        icon: "\u{1F528}",
        text: "Break Down Task",
        action: () => this.openTaskBreakdown()
      },
      {
        icon: "\u{1F91D}",
        text: "Body Doubling",
        action: () => this.startBodyDoubling()
      },
      {
        icon: "\u{1F9D8}",
        text: "Quick Breathing",
        action: () => this.startBreathingExercise()
      },
      {
        icon: "\u{1F4DD}",
        text: "Quick Note",
        action: () => this.createQuickNote()
      },
      {
        icon: "\u{1F3B2}",
        text: "Random Task",
        action: () => this.getRandomTask()
      },
      {
        icon: "\u{1F4A1}",
        text: "Motivation Boost",
        action: () => this.getMotivationBoost()
      }
    ];
    actions.forEach(({ icon, text, action }) => {
      const button = actionsGrid.createEl("button", {
        cls: "action-button",
        text: `${icon} ${text}`
      });
      button.onclick = action;
    });
  }
  renderADHDSupportSection(container) {
    const supportSection = container.createEl("div", { cls: "adhd-support-section" });
    supportSection.createEl("h3", { text: "\u{1F9E0} ADHD Support" });
    const patternsDiv = supportSection.createEl("div", { cls: "patterns-display" });
    patternsDiv.createEl("p", { text: "No patterns detected yet. I'll learn your rhythms over time." });
    const supportTools = supportSection.createEl("div", { cls: "support-tools" });
    const tools = [
      {
        name: "Procrastination Help",
        icon: "\u{1F198}",
        action: () => this.triggerProcrastinationHelp()
      },
      {
        name: "Time Anchor",
        icon: "\u23F0",
        action: () => this.showTimeAnchor()
      },
      {
        name: "Overwhelm Reset",
        icon: "\u{1F504}",
        action: () => this.overwhelmReset()
      }
    ];
    tools.forEach(({ name, icon, action }) => {
      const toolButton = supportTools.createEl("button", {
        cls: "support-tool-btn",
        text: `${icon} ${name}`
      });
      toolButton.onclick = action;
    });
  }
  // Event handlers and actions
  async updateEnergyLevel(level) {
    this.currentEnergyLevel = level;
    await this.integrationService.updateEnergyLevel(level);
    await this.refreshTaskSuggestions();
    this.updateEnergyRecommendations();
  }
  refreshEnergyDisplay() {
    const energyButtons = this.containerEl.querySelectorAll(".energy-button");
    energyButtons.forEach((button, index) => {
      const levels = ["high", "moderate", "low", "depleted"];
      button.removeClass("active");
      if (levels[index] === this.currentEnergyLevel) {
        button.addClass("active");
      }
    });
  }
  updateEnergyRecommendations(container) {
    if (!container) {
      container = this.containerEl.querySelector(".energy-recommendations");
    }
    if (!container)
      return;
    container.empty();
    const recommendations = this.getEnergyBasedRecommendations();
    recommendations.forEach((rec) => {
      const recEl = container.createEl("div", {
        cls: "energy-recommendation",
        text: `\u{1F4A1} ${rec}`
      });
    });
  }
  getEnergyBasedRecommendations() {
    switch (this.currentEnergyLevel) {
      case "high":
        return [
          "Perfect time for complex writing or analysis",
          "Consider tackling that difficult section",
          "Great for creative brainstorming"
        ];
      case "moderate":
        return [
          "Good for steady writing progress",
          "Ideal for reviewing and editing",
          "Try organizing your notes"
        ];
      case "low":
        return [
          "Perfect for simple, routine tasks",
          "Try reading and highlighting",
          "Organize files or references"
        ];
      case "depleted":
        return [
          "Time for rest and self-care",
          "Light tasks like email checking",
          "Consider a short break or nap"
        ];
      default:
        return ["Update your energy level for personalized suggestions"];
    }
  }
  async refreshTaskSuggestions() {
    const suggestions = await this.integrationService.getTaskSuggestions(this.currentEnergyLevel);
    const container = this.containerEl.querySelector(".tasks-container");
    if (container) {
      this.renderTaskList(container, suggestions);
    }
  }
  renderTaskList(container, tasks) {
    container.empty();
    const tasksToShow = tasks || this.getDefaultTasks();
    if (tasksToShow.length === 0) {
      container.createEl("p", {
        text: "No tasks available. Try breaking down a larger goal!",
        cls: "no-tasks-message"
      });
      return;
    }
    tasksToShow.forEach((task, index) => {
      const taskEl = container.createEl("div", { cls: "task-item" });
      const taskHeader = taskEl.createEl("div", { cls: "task-header" });
      taskHeader.createEl("span", { cls: "task-title", text: task.title });
      taskHeader.createEl("span", { cls: "task-time", text: `\u23F1\uFE0F ${task.estimatedMinutes}min` });
      if (task.description) {
        taskEl.createEl("p", { cls: "task-description", text: task.description });
      }
      const taskActions = taskEl.createEl("div", { cls: "task-actions" });
      const startButton = taskActions.createEl("button", {
        text: "\u25B6\uFE0F Start",
        cls: "task-start-btn"
      });
      startButton.onclick = () => this.startTask(task);
      const breakdownButton = taskActions.createEl("button", {
        text: "\u{1F528} Break Down",
        cls: "task-breakdown-btn"
      });
      breakdownButton.onclick = () => this.breakdownTask(task);
    });
  }
  getDefaultTasks() {
    return [
      {
        id: "default-1",
        title: "Review today's writing goals",
        description: "Quick 5-minute check of what you want to accomplish",
        estimatedMinutes: 5,
        complexity: "micro"
      },
      {
        id: "default-2",
        title: "Organize one reference",
        description: "Add one paper to your reference manager",
        estimatedMinutes: 10,
        complexity: "simple"
      },
      {
        id: "default-3",
        title: "Write one paragraph",
        description: "Draft one paragraph for any section",
        estimatedMinutes: 15,
        complexity: "simple"
      }
    ];
  }
  startFocusTimer(minutes) {
    console.log(`Starting ${minutes} minute focus timer`);
  }
  async startTask(task) {
    this.currentFocus = task.title;
    await this.integrationService.startTask(task);
    const focusInput = this.containerEl.querySelector(".focus-input");
    if (focusInput) {
      focusInput.value = this.currentFocus;
    }
  }
  openTaskBreakdown() {
    console.log("Opening task breakdown");
  }
  startBodyDoubling() {
    console.log("Starting body doubling");
  }
  startBreathingExercise() {
    const modal = new BreathingModal(this.app);
    modal.open();
  }
  createQuickNote() {
    this.integrationService.createQuickNote();
  }
  getRandomTask() {
    const randomTasks = this.getDefaultTasks();
    const randomTask = randomTasks[Math.floor(Math.random() * randomTasks.length)];
    this.startTask(randomTask);
  }
  getMotivationBoost() {
    const motivations = [
      "You're doing important work! \u{1F31F}",
      "Every word counts toward your goal! \u{1F4DD}",
      "Your ADHD brain brings unique insights! \u{1F9E0}",
      "Progress over perfection! \u{1F4AA}",
      "You've overcome challenges before! \u{1F3AF}"
    ];
    const motivation = motivations[Math.floor(Math.random() * motivations.length)];
    new import_obsidian2.Notice(motivation);
  }
  triggerProcrastinationHelp() {
    console.log("Triggering procrastination help");
  }
  showTimeAnchor() {
    const now = new Date();
    const timeString = now.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    new import_obsidian2.Notice(`\u{1F550} Time anchor: It's currently ${timeString}`);
  }
  overwhelmReset() {
    console.log("Overwhelm reset triggered");
  }
  celebrateProgress() {
    console.log("Celebrating progress");
  }
  async loadTodaysTasks() {
    this.todaysTasks = await this.integrationService.getTodaysTasks();
  }
};
var BreathingModal = class extends import_obsidian2.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "\u{1F9D8} Quick Breathing Exercise" });
    const instructions = contentEl.createEl("div", { cls: "breathing-instructions" });
    instructions.createEl("p", { text: "Follow along with this simple breathing pattern:" });
    const breathingPattern = contentEl.createEl("div", { cls: "breathing-pattern" });
    const breathingCircle = breathingPattern.createEl("div", { cls: "breathing-circle" });
    const instructionText = contentEl.createEl("p", {
      cls: "breathing-instruction",
      text: "Get ready..."
    });
    this.startBreathingSequence(instructionText, breathingCircle);
    const closeButton = contentEl.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    closeButton.onclick = () => this.close();
  }
  startBreathingSequence(instructionEl, circleEl) {
    const sequence = [
      { text: "Breathe in...", duration: 4e3, action: "expand" },
      { text: "Hold...", duration: 2e3, action: "hold" },
      { text: "Breathe out...", duration: 6e3, action: "contract" },
      { text: "Pause...", duration: 2e3, action: "hold" }
    ];
    let cycleCount = 0;
    const maxCycles = 3;
    const runCycle = () => {
      if (cycleCount >= maxCycles) {
        instructionEl.textContent = "Great job! You're centered and ready to focus. \u{1F31F}";
        return;
      }
      let stepIndex = 0;
      const runStep = () => {
        if (stepIndex >= sequence.length) {
          cycleCount++;
          setTimeout(runCycle, 500);
          return;
        }
        const step = sequence[stepIndex];
        instructionEl.textContent = step.text;
        circleEl.removeClass("expand", "contract");
        if (step.action === "expand") {
          circleEl.addClass("expand");
        } else if (step.action === "contract") {
          circleEl.addClass("contract");
        }
        stepIndex++;
        setTimeout(runStep, step.duration);
      };
      runStep();
    };
    setTimeout(runCycle, 1e3);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/task-breakdown-modal.ts
var import_obsidian3 = require("obsidian");
var TaskBreakdownModal = class extends import_obsidian3.Modal {
  constructor(app, settings, integrationService, sourceFile) {
    super(app);
    this.selectedText = "";
    this.isProcessing = false;
    this.settings = settings;
    this.integrationService = integrationService;
    this.apiClient = new ProactivityApiClient(settings);
    this.sourceFile = sourceFile || null;
  }
  async onOpen() {
    var _a;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("proactive-task-breakdown-modal");
    this.selectedText = await this.integrationService.getSelectedText() || "";
    this.createHeader();
    this.createTaskInputSection();
    this.createContextSection();
    this.createOptionsSection();
    this.createActionButtons();
    this.createBreakdownDisplay();
    if (this.selectedText) {
      this.taskInput.value = `Work on: "${this.selectedText.substring(0, 100)}..."`;
      this.contextInput.value = `Selected text from ${((_a = this.sourceFile) == null ? void 0 : _a.name) || "current file"}`;
    } else if (this.sourceFile) {
      this.taskInput.value = `Continue work on ${this.sourceFile.name}`;
      this.contextInput.value = `Working on file: ${this.sourceFile.path}`;
    }
  }
  createHeader() {
    const { contentEl } = this;
    const header = contentEl.createEl("div", { cls: "modal-header" });
    header.createEl("h2", { text: "\u{1F528} AI Task Breakdown" });
    header.createEl("p", {
      text: "Break down overwhelming tasks into ADHD-friendly micro-steps",
      cls: "modal-subtitle"
    });
  }
  createTaskInputSection() {
    const { contentEl } = this;
    const section = contentEl.createEl("div", { cls: "input-section" });
    section.createEl("label", { text: "What do you want to work on?" });
    this.taskInput = section.createEl("input", {
      type: "text",
      placeholder: 'e.g., "Write the methodology section" or "Analyze survey data"',
      cls: "task-input"
    });
    const suggestions = section.createEl("div", { cls: "quick-suggestions" });
    suggestions.createEl("span", { text: "Quick suggestions: " });
    const suggestionItems = [
      "Write one paragraph",
      "Review one paper",
      "Organize notes",
      "Plan next section"
    ];
    suggestionItems.forEach((suggestion) => {
      const button = suggestions.createEl("button", {
        text: suggestion,
        cls: "suggestion-btn"
      });
      button.onclick = () => {
        this.taskInput.value = suggestion;
      };
    });
  }
  createContextSection() {
    const { contentEl } = this;
    const section = contentEl.createEl("div", { cls: "input-section" });
    section.createEl("label", { text: "Additional context (optional)" });
    this.contextInput = section.createEl("textarea", {
      placeholder: "Any relevant details, constraints, or background information...",
      cls: "context-input"
    });
  }
  createOptionsSection() {
    const { contentEl } = this;
    const section = contentEl.createEl("div", { cls: "options-section" });
    const depthContainer = section.createEl("div", { cls: "option-container" });
    depthContainer.createEl("label", { text: "Breakdown detail level" });
    this.depthSlider = depthContainer.createEl("input", {
      type: "range",
      cls: "depth-slider"
    });
    this.depthSlider.min = "1";
    this.depthSlider.max = "5";
    this.depthSlider.value = this.settings.defaultBreakdownDepth.toString();
    const depthLabel = depthContainer.createEl("span", {
      text: this.getDepthLabel(this.settings.defaultBreakdownDepth),
      cls: "depth-label"
    });
    this.depthSlider.oninput = () => {
      const depth = parseInt(this.depthSlider.value);
      depthLabel.textContent = this.getDepthLabel(depth);
    };
    const energyContainer = section.createEl("div", { cls: "option-container" });
    energyContainer.createEl("label", { text: "Your current energy level" });
    this.energySelect = energyContainer.createEl("select", { cls: "energy-select" });
    const energyOptions = [
      { value: "high", text: "\u26A1 High - Ready for complex tasks" },
      { value: "moderate", text: "\u{1F50B} Moderate - Normal capacity" },
      { value: "low", text: "\u{1FAAB} Low - Simple tasks only" },
      { value: "depleted", text: "\u{1F634} Depleted - Need rest/micro-tasks" }
    ];
    energyOptions.forEach((option) => {
      const optionEl = this.energySelect.createEl("option", {
        value: option.value,
        text: option.text
      });
      if (option.value === "moderate") {
        optionEl.selected = true;
      }
    });
    const timeContainer = section.createEl("div", { cls: "option-container" });
    timeContainer.createEl("label", { text: "Available time (minutes)" });
    this.timeInput = timeContainer.createEl("input", {
      type: "number",
      cls: "time-input"
    });
    this.timeInput.min = "5";
    this.timeInput.max = "180";
    this.timeInput.value = "30";
  }
  createActionButtons() {
    const { contentEl } = this;
    const buttonContainer = contentEl.createEl("div", { cls: "button-container" });
    const breakdownBtn = buttonContainer.createEl("button", {
      text: "\u{1F916} Break Down Task",
      cls: "mod-cta breakdown-btn"
    });
    breakdownBtn.onclick = () => this.performBreakdown();
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "cancel-btn"
    });
    cancelBtn.onclick = () => this.close();
  }
  createBreakdownDisplay() {
    const { contentEl } = this;
    this.breakdownContainer = contentEl.createEl("div", { cls: "breakdown-container" });
  }
  getDepthLabel(depth) {
    const labels = {
      1: "Basic (2-3 steps)",
      2: "Simple (3-5 steps)",
      3: "Detailed (5-8 steps)",
      4: "Very Detailed (8-12 steps)",
      5: "Micro-steps (12+ steps)"
    };
    return labels[depth] || "Detailed";
  }
  async performBreakdown() {
    var _a;
    if (this.isProcessing)
      return;
    const task = this.taskInput.value.trim();
    if (!task) {
      new import_obsidian3.Notice("Please enter a task to break down");
      return;
    }
    this.isProcessing = true;
    this.showProcessingState();
    try {
      const breakdown = await this.requestTaskBreakdown({
        task,
        context: this.contextInput.value.trim(),
        depth: parseInt(this.depthSlider.value),
        energyLevel: this.energySelect.value,
        availableTime: parseInt(this.timeInput.value),
        sourceFile: (_a = this.sourceFile) == null ? void 0 : _a.path,
        selectedText: this.selectedText
      });
      this.displayBreakdown(breakdown);
    } catch (error) {
      console.error("Task breakdown error:", error);
      this.showError("Failed to break down task. Please try again.");
    } finally {
      this.isProcessing = false;
    }
  }
  showProcessingState() {
    this.breakdownContainer.empty();
    this.breakdownContainer.addClass("processing");
    const processing = this.breakdownContainer.createEl("div", { cls: "processing-message" });
    processing.createEl("div", { cls: "spinner" });
    processing.createEl("p", { text: "\u{1F916} Breaking down your task into ADHD-friendly steps..." });
    processing.createEl("p", {
      text: "This usually takes 10-15 seconds",
      cls: "processing-subtitle"
    });
  }
  showError(message) {
    this.breakdownContainer.empty();
    this.breakdownContainer.removeClass("processing");
    const error = this.breakdownContainer.createEl("div", { cls: "error-message" });
    error.createEl("p", { text: "\u274C " + message });
    const retryBtn = error.createEl("button", {
      text: "Try Again",
      cls: "retry-btn"
    });
    retryBtn.onclick = () => this.performBreakdown();
  }
  displayBreakdown(breakdown) {
    this.breakdownContainer.empty();
    this.breakdownContainer.removeClass("processing");
    if (!breakdown || !breakdown.steps || breakdown.steps.length === 0) {
      this.showError("No breakdown steps received");
      return;
    }
    const header = this.breakdownContainer.createEl("div", { cls: "breakdown-header" });
    header.createEl("h3", { text: "\u2728 Your ADHD-Friendly Task Breakdown" });
    if (breakdown.motivation) {
      header.createEl("p", {
        text: breakdown.motivation,
        cls: "motivation-message"
      });
    }
    const stepsList = this.breakdownContainer.createEl("div", { cls: "steps-list" });
    breakdown.steps.forEach((step, index) => {
      const stepEl = stepsList.createEl("div", { cls: "breakdown-step" });
      const stepHeader = stepEl.createEl("div", { cls: "step-header" });
      stepHeader.createEl("span", {
        text: `${index + 1}.`,
        cls: "step-number"
      });
      stepHeader.createEl("h4", {
        text: step.title,
        cls: "step-title"
      });
      stepHeader.createEl("span", {
        text: `\u23F1\uFE0F ${step.estimatedMinutes}min`,
        cls: "step-time"
      });
      if (step.description) {
        stepEl.createEl("p", {
          text: step.description,
          cls: "step-description"
        });
      }
      if (step.tips && step.tips.length > 0) {
        const tipsList = stepEl.createEl("ul", { cls: "step-tips" });
        step.tips.forEach((tip) => {
          tipsList.createEl("li", { text: tip });
        });
      }
      const stepActions = stepEl.createEl("div", { cls: "step-actions" });
      const startBtn = stepActions.createEl("button", {
        text: "\u25B6\uFE0F Start",
        cls: "step-start-btn"
      });
      startBtn.onclick = () => this.startStep(step);
      const addToVaultBtn = stepActions.createEl("button", {
        text: "\u{1F4DD} Add to Daily Note",
        cls: "step-add-btn"
      });
      addToVaultBtn.onclick = () => this.addStepToVault(step);
    });
    const footer = this.breakdownContainer.createEl("div", { cls: "breakdown-footer" });
    const addAllBtn = footer.createEl("button", {
      text: "\u{1F4CB} Add All Steps to Daily Note",
      cls: "mod-cta"
    });
    addAllBtn.onclick = () => this.addAllStepsToVault(breakdown.steps);
    const newBreakdownBtn = footer.createEl("button", {
      text: "\u{1F504} Try Different Breakdown",
      cls: "secondary-btn"
    });
    newBreakdownBtn.onclick = () => {
      this.breakdownContainer.empty();
    };
  }
  // Use the integrated approach from ObsidianIntegrationService which has both OpenAI direct and fallback
  async requestTaskBreakdown(params) {
    return await this.integrationService.breakdownTask(params.task, {
      energyLevel: params.energyLevel,
      depth: params.depth,
      availableTime: params.availableTime,
      context: params.context || ""
    });
  }
  async startStep(step) {
    await this.integrationService.startTask({
      title: step.title,
      description: step.description,
      estimatedMinutes: step.estimatedMinutes,
      complexity: step.complexity
    });
    new import_obsidian3.Notice(`Started: ${step.title} (${step.estimatedMinutes}min)`);
    this.close();
  }
  async addStepToVault(step) {
    const dailyNotePath = await this.getDailyNotePath();
    if (!dailyNotePath) {
      new import_obsidian3.Notice("Unable to find daily note");
      return;
    }
    try {
      const file = await this.getOrCreateFile(dailyNotePath);
      const content = await this.app.vault.read(file);
      const taskEntry = `- [ ] ${step.title} (${step.estimatedMinutes}min)${step.description ? ` - ${step.description}` : ""}
`;
      const updatedContent = this.updateTasksSection(content, taskEntry);
      await this.app.vault.modify(file, updatedContent);
      new import_obsidian3.Notice(`Added "${step.title}" to daily note`);
    } catch (error) {
      console.error("Error adding step to vault:", error);
      new import_obsidian3.Notice("Error adding step to daily note");
    }
  }
  async addAllStepsToVault(steps) {
    const dailyNotePath = await this.getDailyNotePath();
    if (!dailyNotePath) {
      new import_obsidian3.Notice("Unable to find daily note");
      return;
    }
    try {
      const file = await this.getOrCreateFile(dailyNotePath);
      const content = await this.app.vault.read(file);
      const taskEntries = steps.map(
        (step) => `- [ ] ${step.title} (${step.estimatedMinutes}min)${step.description ? ` - ${step.description}` : ""}`
      ).join("\n") + "\n";
      const updatedContent = this.updateTasksSection(content, taskEntries);
      await this.app.vault.modify(file, updatedContent);
      new import_obsidian3.Notice(`Added ${steps.length} tasks to daily note`);
      this.close();
    } catch (error) {
      console.error("Error adding steps to vault:", error);
      new import_obsidian3.Notice("Error adding tasks to daily note");
    }
  }
  async getDailyNotePath() {
    const today = new Date().toISOString().split("T")[0];
    const dailyNoteFolder = this.settings.obsidianIntegration.dailyNotePath;
    return `${dailyNoteFolder}/${today}.md`;
  }
  async getOrCreateFile(path) {
    let file = this.app.vault.getAbstractFileByPath(path);
    if (!file) {
      const template = this.createDailyNoteTemplate();
      file = await this.app.vault.create(path, template);
    }
    return file;
  }
  createDailyNoteTemplate() {
    const today = new Date().toLocaleDateString();
    return `# Daily Note - ${today}

${this.settings.obsidianIntegration.taskTagPrefix}/daily-note

## Energy Tracking

## Current Focus

## Tasks

## Progress

## Celebrations

## Reflections

---
*Generated by Proactivity*`;
  }
  updateTasksSection(content, newTasks) {
    const tasksSection = "## Tasks";
    const sectionRegex = new RegExp(`(${tasksSection}\\n)[\\s\\S]*?(?=\\n## |\\n---|$)`, "i");
    if (sectionRegex.test(content)) {
      return content.replace(sectionRegex, `${tasksSection}

${newTasks}`);
    } else {
      const dividerIndex = content.lastIndexOf("\n---");
      if (dividerIndex !== -1) {
        return content.slice(0, dividerIndex) + `
${tasksSection}

${newTasks}
` + content.slice(dividerIndex);
      } else {
        return content + `

${tasksSection}

${newTasks}`;
      }
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/adhd-pattern-detector.ts
var import_obsidian4 = require("obsidian");
var ADHDPatternDetector = class {
  constructor(app, settings) {
    this.activityHistory = [];
    this.currentSession = null;
    this.detectionInterval = null;
    this.lastFileActivity = Date.now();
    this.currentFile = null;
    this.consecutiveFileSwitches = 0;
    this.hyperfocusStartTime = null;
    this.isDetectionActive = false;
    this.app = app;
    this.settings = settings;
    this.setupEventListeners();
  }
  startDetection() {
    if (this.isDetectionActive)
      return;
    this.isDetectionActive = true;
    this.startNewSession();
    this.detectionInterval = setInterval(() => {
      this.analyzePatterns();
    }, 5 * 60 * 1e3);
    console.log("ADHD pattern detection started");
  }
  stopDetection() {
    if (!this.isDetectionActive)
      return;
    this.isDetectionActive = false;
    if (this.detectionInterval) {
      clearInterval(this.detectionInterval);
      this.detectionInterval = null;
    }
    this.endCurrentSession();
    console.log("ADHD pattern detection stopped");
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  getCurrentPatterns() {
    return this.analyzeCurrentBehavior();
  }
  checkFocusState() {
    if (!this.isDetectionActive)
      return;
    const now = Date.now();
    const inactiveMinutes = (now - this.lastFileActivity) / (1e3 * 60);
    if (this.hyperfocusStartTime) {
      const hyperfocusDuration = (now - this.hyperfocusStartTime) / (1e3 * 60);
      if (hyperfocusDuration > 90 && this.settings.enableHyperfocusProtection) {
        this.triggerHyperfocusWarning(hyperfocusDuration);
      }
    }
    if (inactiveMinutes > this.settings.procrastinationThreshold) {
      this.triggerProcrastinationDetection(inactiveMinutes);
    }
  }
  setupEventListeners() {
    this.app.workspace.on("file-open", (file) => {
      this.recordActivity("file_open", { file: file == null ? void 0 : file.path });
      this.handleFileActivity((file == null ? void 0 : file.path) || null);
    });
    this.app.vault.on("modify", (file) => {
      this.recordActivity("file_edit", { file: file.path });
      this.handleFileActivity(file.path);
    });
    this.app.workspace.on("active-leaf-change", () => {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile && activeFile.path !== this.currentFile) {
        this.handleFileSwitch(activeFile.path);
      }
    });
  }
  handleFileActivity(filePath) {
    const now = Date.now();
    const timeSinceLastActivity = now - this.lastFileActivity;
    this.lastFileActivity = now;
    if (timeSinceLastActivity < 5 * 60 * 1e3) {
      if (!this.hyperfocusStartTime) {
        this.hyperfocusStartTime = now;
      }
    } else {
      this.hyperfocusStartTime = null;
    }
    if (this.currentSession) {
      this.currentSession.activities.push({
        timestamp: now,
        type: "file_edit",
        data: { file: filePath }
      });
    }
  }
  handleFileSwitch(newFilePath) {
    if (this.currentFile && this.currentFile !== newFilePath) {
      this.consecutiveFileSwitches++;
      this.recordActivity("file_switch", {
        from: this.currentFile,
        to: newFilePath,
        consecutiveSwitches: this.consecutiveFileSwitches
      });
      if (this.consecutiveFileSwitches > 5) {
        this.triggerTaskSwitchingDetection();
      }
    } else {
      this.consecutiveFileSwitches = 0;
    }
    this.currentFile = newFilePath;
  }
  recordActivity(type, data) {
    const event = {
      timestamp: Date.now(),
      type,
      data
    };
    this.activityHistory.push(event);
    const cutoff = Date.now() - 24 * 60 * 60 * 1e3;
    this.activityHistory = this.activityHistory.filter((event2) => event2.timestamp > cutoff);
  }
  startNewSession() {
    this.endCurrentSession();
    this.currentSession = {
      startTime: Date.now(),
      activities: [],
      focusScore: 0,
      tasksCompleted: 0,
      filesModified: 0
    };
  }
  endCurrentSession() {
    if (this.currentSession) {
      this.currentSession.endTime = Date.now();
      this.calculateSessionMetrics();
    }
  }
  calculateSessionMetrics() {
    if (!this.currentSession)
      return;
    const session = this.currentSession;
    const duration = (session.endTime || Date.now()) - session.startTime;
    const activityGaps = this.calculateActivityGaps(session.activities);
    session.focusScore = this.calculateFocusScore(activityGaps, duration);
    session.filesModified = session.activities.filter((a) => a.type === "file_edit").length;
  }
  calculateActivityGaps(activities) {
    const gaps = [];
    for (let i = 1; i < activities.length; i++) {
      gaps.push(activities[i].timestamp - activities[i - 1].timestamp);
    }
    return gaps;
  }
  calculateFocusScore(gaps, duration) {
    if (gaps.length === 0)
      return 0;
    const averageGap = gaps.reduce((sum, gap) => sum + gap, 0) / gaps.length;
    const maxGap = Math.max(...gaps);
    const consistencyScore = 1 - (maxGap - averageGap) / duration;
    const activityScore = Math.min(gaps.length / (duration / (10 * 60 * 1e3)), 1);
    return Math.max(0, Math.min(1, (consistencyScore + activityScore) / 2));
  }
  analyzePatterns() {
    const patterns = [];
    patterns.push(...this.detectProcrastinationPattern());
    patterns.push(...this.detectHyperfocusPattern());
    patterns.push(...this.detectTaskSwitchingPattern());
    patterns.push(...this.detectEnergyPattern());
    patterns.push(...this.detectProductiveTimePattern());
    return patterns;
  }
  analyzeCurrentBehavior() {
    return this.analyzePatterns();
  }
  detectProcrastinationPattern() {
    const now = Date.now();
    const recentActivity = this.activityHistory.filter(
      (event) => now - event.timestamp < 60 * 60 * 1e3
      // Last hour
    );
    if (recentActivity.length < 3) {
      const inactiveMinutes = (now - this.lastFileActivity) / (1e3 * 60);
      if (inactiveMinutes > this.settings.procrastinationThreshold) {
        return [{
          type: "procrastination",
          confidence: Math.min(0.9, inactiveMinutes / 60),
          description: `Low activity detected for ${Math.round(inactiveMinutes)} minutes`,
          suggestions: [
            "Try the 2-minute rule: commit to just 2 minutes of work",
            "Break your task into smaller micro-steps",
            "Use the Pomodoro technique with shorter intervals",
            "Consider if this is the right energy level for this task"
          ],
          healthConcern: false,
          detected: now
        }];
      }
    }
    return [];
  }
  detectHyperfocusPattern() {
    if (!this.hyperfocusStartTime)
      return [];
    const now = Date.now();
    const hyperfocusDuration = (now - this.hyperfocusStartTime) / (1e3 * 60);
    if (hyperfocusDuration > 60) {
      return [{
        type: "hyperfocus",
        confidence: Math.min(0.9, hyperfocusDuration / 120),
        description: `Sustained focus session: ${Math.round(hyperfocusDuration)} minutes`,
        suggestions: [
          "Great focus! Consider taking a 5-10 minute break soon",
          "Hydrate and stretch to maintain this energy",
          "Set a gentle reminder to check in with your body",
          "Remember to eat if it's been a while"
        ],
        healthConcern: hyperfocusDuration > 120,
        // Health concern after 2 hours
        detected: now
      }];
    }
    return [];
  }
  detectTaskSwitchingPattern() {
    const recentSwitches = this.activityHistory.filter(
      (event) => event.type === "file_switch" && Date.now() - event.timestamp < 30 * 60 * 1e3
      // Last 30 minutes
    );
    if (recentSwitches.length > 8) {
      return [{
        type: "task_switching",
        confidence: Math.min(0.9, recentSwitches.length / 15),
        description: `High task switching: ${recentSwitches.length} file changes in 30 minutes`,
        suggestions: [
          "You seem to be jumping between tasks - this is totally normal with ADHD!",
          "Try closing extra tabs to reduce visual distractions",
          "Pick one file to focus on for the next 15 minutes",
          "Consider if you need a break or different type of task"
        ],
        healthConcern: false,
        detected: Date.now()
      }];
    }
    return [];
  }
  detectEnergyPattern() {
    return [];
  }
  detectProductiveTimePattern() {
    if (!this.currentSession)
      return [];
    const sessionDuration = (Date.now() - this.currentSession.startTime) / (1e3 * 60);
    if (sessionDuration > 25 && this.currentSession.focusScore > 0.7) {
      return [{
        type: "productive_time",
        confidence: this.currentSession.focusScore,
        description: `High productivity session: ${Math.round(sessionDuration)} minutes`,
        suggestions: [
          "You're in a great flow state!",
          "Your ADHD brain is working well right now",
          "Consider what factors are helping you focus today",
          "Remember this pattern for future reference"
        ],
        healthConcern: false,
        detected: Date.now()
      }];
    }
    return [];
  }
  triggerHyperfocusWarning(duration) {
    if (!this.settings.enableHyperfocusProtection)
      return;
    const hours = Math.floor(duration / 60);
    const minutes = Math.round(duration % 60);
    new import_obsidian4.Notice(
      `\u{1F499} Hyperfocus check-in: You've been focused for ${hours}h ${minutes}m. Consider a gentle break for your wellbeing.`,
      8e3
    );
  }
  triggerProcrastinationDetection(inactiveMinutes) {
    const roundedMinutes = Math.round(inactiveMinutes);
    new import_obsidian4.Notice(
      `\u{1F917} Gentle nudge: It's been ${roundedMinutes} minutes since your last activity. No judgment - want to try a tiny step?`,
      6e3
    );
  }
  triggerTaskSwitchingDetection() {
    new import_obsidian4.Notice(
      `\u{1F9E0} I notice you're switching between tasks frequently - totally normal with ADHD! Maybe try focusing on one file for 10 minutes?`,
      7e3
    );
    this.consecutiveFileSwitches = 0;
  }
  // Public methods for external use
  recordEnergyUpdate(energyLevel) {
    this.recordActivity("energy_update", { energyLevel });
  }
  recordTaskStart(task) {
    this.recordActivity("task_start", { task });
    if (this.currentSession) {
      this.currentSession.tasksCompleted++;
    }
  }
  recordTaskComplete(task) {
    this.recordActivity("task_complete", { task });
  }
  getSessionSummary() {
    if (!this.currentSession)
      return null;
    const duration = (Date.now() - this.currentSession.startTime) / (1e3 * 60);
    return {
      duration: Math.round(duration),
      focusScore: this.currentSession.focusScore,
      tasksCompleted: this.currentSession.tasksCompleted,
      filesModified: this.currentSession.filesModified,
      patterns: this.getCurrentPatterns()
    };
  }
  exportPatternData() {
    return {
      activityHistory: this.activityHistory,
      currentSession: this.currentSession,
      detectedPatterns: this.getCurrentPatterns(),
      metadata: {
        detectionActive: this.isDetectionActive,
        settingsSnapshot: this.settings
      }
    };
  }
};

// src/obsidian-integration-service.ts
var import_obsidian5 = require("obsidian");
var ObsidianIntegrationService = class {
  constructor(app, settings) {
    this.dailyNotificationCount = 0;
    this.lastNotificationReset = "";
    this.app = app;
    this.settings = settings;
    this.apiClient = new ProactivityApiClient(settings);
    this.resetDailyCountIfNeeded();
  }
  updateSettings(settings) {
    this.settings = settings;
    this.apiClient.updateSettings(settings);
  }
  /**
   * Get current context from Obsidian environment
   */
  async getCurrentContext() {
    const activeFile = this.app.workspace.getActiveFile();
    const openFiles = this.app.workspace.getLeavesOfType("markdown").length;
    const selectedText = await this.getSelectedText();
    return {
      activeFile: (activeFile == null ? void 0 : activeFile.name) || null,
      activeFilePath: (activeFile == null ? void 0 : activeFile.path) || null,
      openFiles,
      selectedText,
      hasUnfinishedTasks: await this.hasUnfinishedTasks(),
      energyLevel: await this.getCurrentEnergyLevel(),
      inactiveForMinutes: this.getInactivityMinutes(),
      currentWorkingDirectory: this.getCurrentWorkingDirectory(),
      recentActivity: await this.getRecentActivity()
    };
  }
  /**
   * Get selected text from the active editor
   */
  async getSelectedText() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!activeView)
      return null;
    const editor = activeView.editor;
    return editor.getSelection() || null;
  }
  /**
   * Create a quick note for capturing thoughts
   */
  async createQuickNote() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const noteName = `Quick Note ${timestamp}`;
    const notePath = `${this.settings.obsidianIntegration.dailyNotePath}/${noteName}.md`;
    const noteContent = `# Quick Note

Created: ${new Date().toLocaleString()}
Tags: ${this.settings.obsidianIntegration.taskTagPrefix}/quick-note

## Thoughts

<!-- Write your thoughts here -->

## Next Actions

<!-- What do you want to do with this idea? -->

---
*Created with Proactivity*`;
    try {
      const file = await this.app.vault.create(notePath, noteContent);
      await this.app.workspace.getLeaf().openFile(file);
      new import_obsidian5.Notice("Quick note created! Start writing your thoughts.");
    } catch (error) {
      console.error("Error creating quick note:", error);
      new import_obsidian5.Notice("Error creating quick note. Check your settings.");
    }
  }
  /**
   * Update user's current energy level
   */
  async updateEnergyLevel(energyLevel) {
    const dailyNotePath = await this.getDailyNotePath();
    if (dailyNotePath) {
      try {
        const file = await this.getOrCreateFile(dailyNotePath);
        const content = await this.app.vault.read(file);
        const energySection = `
## Energy Tracking

- ${new Date().toLocaleTimeString()}: ${energyLevel}
`;
        const updatedContent = this.updateDailyNoteSection(content, "Energy Tracking", energySection);
        await this.app.vault.modify(file, updatedContent);
      } catch (error) {
        console.error("Error updating energy level locally:", error);
      }
    }
    await this.apiClient.safeApiCall(
      () => this.apiClient.updateEnergyLevel(energyLevel),
      void 0,
      "Failed to sync energy level with backend"
    );
  }
  /**
   * Update current focus/task
   */
  async updateCurrentFocus(focus) {
    const dailyNotePath = await this.getDailyNotePath();
    if (!dailyNotePath)
      return;
    try {
      const file = await this.getOrCreateFile(dailyNotePath);
      const content = await this.app.vault.read(file);
      const focusSection = `
## Current Focus

${focus}

Started: ${new Date().toLocaleTimeString()}
`;
      const updatedContent = this.updateDailyNoteSection(content, "Current Focus", focusSection);
      await this.app.vault.modify(file, updatedContent);
    } catch (error) {
      console.error("Error updating current focus:", error);
    }
  }
  /**
   * Start tracking a task
   */
  async startTask(task) {
    const dailyNotePath = await this.getDailyNotePath();
    if (dailyNotePath) {
      try {
        const file = await this.getOrCreateFile(dailyNotePath);
        const content = await this.app.vault.read(file);
        const taskEntry = `- [ ] ${task.title} (${task.estimatedMinutes}min) - Started: ${new Date().toLocaleTimeString()}
`;
        const updatedContent = this.updateDailyNoteSection(content, "Tasks", `
## Tasks

${taskEntry}`);
        await this.app.vault.modify(file, updatedContent);
        new import_obsidian5.Notice(`Started: ${task.title}`);
      } catch (error) {
        console.error("Error starting task locally:", error);
      }
    }
    await this.apiClient.safeApiCall(
      () => this.apiClient.startTask(task.id || `task_${Date.now()}`, task.estimatedMinutes),
      void 0,
      "Failed to sync task start with backend"
    );
    await this.apiClient.safeApiCall(
      () => this.apiClient.recordActivity("task_start", {
        taskId: task.id,
        title: task.title,
        estimatedMinutes: task.estimatedMinutes,
        complexity: task.complexity
      })
    );
  }
  /**
   * Get task suggestions based on current context and energy level
   */
  async getTaskSuggestions(energyLevel) {
    const context = await this.getCurrentContext();
    const backendSuggestions = await this.apiClient.safeApiCall(
      () => this.apiClient.getTaskSuggestions(energyLevel, 30),
      null,
      "Using local task suggestions"
    );
    if (backendSuggestions == null ? void 0 : backendSuggestions.success) {
      return backendSuggestions.data;
    }
    return this.getLocalTaskSuggestions(energyLevel, context);
  }
  async getLocalTaskSuggestions(energyLevel, context) {
    const dissertationFiles = await this.getDissertationFiles();
    const unfinishedTasks = await this.getUnfinishedTasks();
    const suggestions = [];
    switch (energyLevel) {
      case "high":
        suggestions.push(
          {
            title: "Draft a new section",
            description: "Use your high energy for creative writing",
            estimatedMinutes: 45,
            complexity: "complex",
            source: "energy-based"
          },
          {
            title: "Analyze complex data",
            description: "Perfect time for analytical work",
            estimatedMinutes: 60,
            complexity: "complex",
            source: "energy-based"
          }
        );
        break;
      case "moderate":
        suggestions.push(
          {
            title: "Edit existing content",
            description: "Review and improve what you've written",
            estimatedMinutes: 30,
            complexity: "moderate",
            source: "energy-based"
          },
          {
            title: "Organize references",
            description: "Structure your research materials",
            estimatedMinutes: 25,
            complexity: "simple",
            source: "energy-based"
          }
        );
        break;
      case "low":
        suggestions.push(
          {
            title: "Read one paper",
            description: "Light reading and note-taking",
            estimatedMinutes: 20,
            complexity: "simple",
            source: "energy-based"
          },
          {
            title: "Update citation format",
            description: "Simple formatting tasks",
            estimatedMinutes: 15,
            complexity: "micro",
            source: "energy-based"
          }
        );
        break;
      case "depleted":
        suggestions.push(
          {
            title: "Review tomorrow's goals",
            description: "Quick planning for when you're refreshed",
            estimatedMinutes: 10,
            complexity: "micro",
            source: "energy-based"
          }
        );
        break;
    }
    if (context.activeFile && context.activeFile.includes(".md")) {
      suggestions.push({
        title: `Continue work on ${context.activeFile}`,
        description: "Build on your current file",
        estimatedMinutes: 20,
        complexity: "moderate",
        source: "context-based"
      });
    }
    if (context.selectedText) {
      suggestions.push({
        title: "Expand selected text",
        description: "Develop the highlighted section further",
        estimatedMinutes: 15,
        complexity: "simple",
        source: "context-based"
      });
    }
    suggestions.push(...unfinishedTasks.slice(0, 2));
    return suggestions.slice(0, 5).map((task, index) => ({
      ...task,
      id: task.id || `suggestion_${Date.now()}_${index}`,
      adhdOptimized: true
    }));
  }
  /**
   * Check if there are unfinished tasks
   */
  async hasUnfinishedTasks() {
    const tasks = await this.getTodaysTasks();
    return tasks.some((task) => !task.completed);
  }
  /**
   * Get unfinished tasks
   */
  async getUnfinishedTasks() {
    const tasks = await this.getTodaysTasks();
    return tasks.filter((task) => !task.completed).map((task) => ({
      ...task,
      source: "existing-task"
    }));
  }
  /**
   * Log progress celebration for pattern recognition
   */
  async logProgressCelebration() {
    const dailyNotePath = await this.getDailyNotePath();
    if (!dailyNotePath)
      return;
    try {
      const file = await this.getOrCreateFile(dailyNotePath);
      const content = await this.app.vault.read(file);
      const celebrationEntry = `
\u{1F389} Progress celebrated at ${new Date().toLocaleTimeString()}
`;
      const updatedContent = this.updateDailyNoteSection(content, "Celebrations", `
## Celebrations
${celebrationEntry}`);
      await this.app.vault.modify(file, updatedContent);
    } catch (error) {
      console.error("Error logging celebration:", error);
    }
  }
  /**
   * Get recent notification count
   */
  getRecentNotificationCount() {
    this.resetDailyCountIfNeeded();
    return this.dailyNotificationCount;
  }
  /**
   * Increment notification count
   */
  incrementNotificationCount() {
    this.resetDailyCountIfNeeded();
    this.dailyNotificationCount++;
  }
  /**
   * Get user activity metrics
   */
  async getUserActivity() {
    const recentActivity = await this.getRecentActivity();
    const lastActivity = recentActivity[0];
    const inactiveMinutes = lastActivity ? Math.floor((Date.now() - lastActivity.timestamp) / (1e3 * 60)) : 120;
    return {
      inactiveForMinutes: inactiveMinutes,
      seemsStuck: inactiveMinutes > 30 && inactiveMinutes < 120,
      recentFileChanges: recentActivity.length,
      lastActivity: (lastActivity == null ? void 0 : lastActivity.action) || "unknown"
    };
  }
  /**
   * Breakdown a high-level task into actionable steps using OpenAI
   */
  async breakdownTask(rawTask, opts) {
    var _a, _b;
    const { energyLevel = "moderate", depth = 3, availableTime = 30, context = "" } = opts || {};
    if (this.settings.apiKey && this.settings.apiKey.startsWith("sk-")) {
      try {
        return await this.breakdownWithOpenAI(rawTask, { energyLevel, depth, availableTime, context });
      } catch (e) {
        console.warn("OpenAI breakdown failed, trying backend", e);
      }
    }
    const payload = {
      task: rawTask,
      context,
      depth,
      energyLevel,
      availableTime,
      settingsSnapshot: {
        gentleTone: this.settings.adhdSupport.useGentleTone,
        includeMotivation: this.settings.adhdSupport.includeMotivation,
        limitCognitiveLoad: this.settings.adhdSupport.limitCognitiveLoad
      }
    };
    const endpoint = `${this.settings.serverUrl}/api/tasks/breakdown`;
    try {
      const resp = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json", "x-api-key": this.settings.apiKey || "" },
        body: JSON.stringify(payload)
      });
      if (!resp.ok)
        throw new Error("HTTP " + resp.status);
      const json = await resp.json();
      if ((_b = (_a = json == null ? void 0 : json.data) == null ? void 0 : _a.steps) == null ? void 0 : _b.length) {
        return {
          motivation: json.data.motivation,
          steps: json.data.steps.map((s, i) => ({
            id: s.id || `step-${i}`,
            title: s.title,
            description: s.description || "",
            estimatedMinutes: s.estimatedMinutes || 10,
            complexity: s.complexity || "simple",
            tips: s.tips || []
          }))
        };
      }
      throw new Error("Empty steps");
    } catch (e) {
      console.warn("breakdownTask fallback", e);
      return this.getFallbackBreakdown(rawTask, depth);
    }
  }
  /**
   * Parse tasks from raw text
   */
  parseTasksFromText(text) {
    const lines = text.split(/\r?\n/);
    const tasks = [];
    const taskRegex = /^(\s*)- \[( |x)\] (.+)$/;
    for (const line of lines) {
      const m = line.match(taskRegex);
      if (m) {
        const indent = m[1];
        const full = m[3];
        const timeMatch = full.match(/\((\d+)min\)/);
        const est = timeMatch ? parseInt(timeMatch[1]) : void 0;
        const title = full.replace(/\s*\(\d+min\).*/, "");
        tasks.push({ line, title: title.trim(), indent, estimatedMinutes: est });
      }
    }
    return tasks;
  }
  /**
   * Generate AI-powered clarifying questions for a task
   */
  async generateClarifyingQuestions(taskTitle, context) {
    if (this.settings.apiKey && this.settings.apiKey.startsWith("sk-")) {
      try {
        return await this.generateAIClarifyingQuestions(taskTitle, context);
      } catch (e) {
        console.warn("AI clarifying questions failed, using fallback", e);
      }
    }
    return this.getFallbackClarifyingQuestions(taskTitle);
  }
  // Private helper methods
  async getDailyNotePath() {
    const today = new Date().toISOString().split("T")[0];
    const dailyNoteFolder = this.settings.obsidianIntegration.dailyNotePath;
    return `${dailyNoteFolder}/${today}.md`;
  }
  async getOrCreateFile(path) {
    let file = this.app.vault.getAbstractFileByPath(path);
    if (!file) {
      const template = this.createDailyNoteTemplate();
      file = await this.app.vault.create(path, template);
    }
    return file;
  }
  createDailyNoteTemplate() {
    const today = new Date().toLocaleDateString();
    return `# Daily Note - ${today}

${this.settings.obsidianIntegration.taskTagPrefix}/daily-note

## Energy Tracking

## Current Focus

## Tasks

## Progress

## Celebrations

## Reflections

---
*Generated by Proactivity*`;
  }
  updateDailyNoteSection(content, sectionName, newSection) {
    const sectionRegex = new RegExp(`(## ${sectionName}\\n)[\\s\\S]*?(?=\\n## |\\n---|$)`, "i");
    if (sectionRegex.test(content)) {
      return content.replace(sectionRegex, newSection);
    } else {
      const dividerIndex = content.lastIndexOf("\n---");
      if (dividerIndex !== -1) {
        return content.slice(0, dividerIndex) + newSection + "\n" + content.slice(dividerIndex);
      } else {
        return content + "\n" + newSection;
      }
    }
  }
  extractTasksFromContent(content) {
    const taskRegex = /^- \[([ x])\] (.+)$/gm;
    const tasks = [];
    let match;
    while ((match = taskRegex.exec(content)) !== null) {
      const completed = match[1] === "x";
      const title = match[2];
      const timeMatch = title.match(/\((\d+)min\)/);
      const estimatedMinutes = timeMatch ? parseInt(timeMatch[1]) : 30;
      tasks.push({
        title: title.replace(/\s*\(\d+min\).*$/, ""),
        completed,
        estimatedMinutes,
        complexity: estimatedMinutes <= 15 ? "micro" : estimatedMinutes <= 30 ? "simple" : "moderate"
      });
    }
    return tasks;
  }
  async getDissertationFiles() {
    const dissertationPath = this.settings.obsidianIntegration.dissertationFolderPath;
    const folder = this.app.vault.getAbstractFileByPath(dissertationPath);
    if (!folder || !(folder instanceof import_obsidian5.TFolder))
      return [];
    return folder.children.filter((file) => file instanceof import_obsidian5.TFile && file.extension === "md");
  }
  getCurrentWorkingDirectory() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return "";
    const pathParts = activeFile.path.split("/");
    return pathParts.slice(0, -1).join("/");
  }
  async getRecentActivity() {
    return [
      {
        timestamp: Date.now() - 10 * 60 * 1e3,
        // 10 minutes ago
        action: "file_modified",
        file: "Chapter 3.md"
      }
    ];
  }
  async getCurrentEnergyLevel() {
    return "moderate";
  }
  getInactivityMinutes() {
    return 25;
  }
  resetDailyCountIfNeeded() {
    const today = new Date().toDateString();
    if (this.lastNotificationReset !== today) {
      this.dailyNotificationCount = 0;
      this.lastNotificationReset = today;
    }
  }
  /**
   * Direct OpenAI breakdown using stored API key
   */
  async breakdownWithOpenAI(rawTask, opts) {
    var _a, _b;
    const { energyLevel = "moderate", depth = 3, availableTime = 30, context = "" } = opts;
    const granularityPrompt = depth <= 2 ? "high-level actionable steps" : depth === 3 ? "detailed micro-steps (5-15 minutes each)" : "extremely granular micro-tasks (2-8 minutes each)";
    const systemPrompt = `You are an ADHD-aware task breakdown assistant. Break down tasks into ${granularityPrompt} that are:
- Specific and actionable (start with action verbs)
- Appropriately sized for ${energyLevel} energy level
- Include time estimates
- Consider ADHD challenges like executive dysfunction and overwhelm

Energy context: ${energyLevel}
Available time: ${availableTime} minutes
Additional context: ${context || "None"}

Return JSON with: { "motivation": "brief encouraging note", "steps": [{"title": "action", "description": "details", "estimatedMinutes": number, "complexity": "micro|simple|moderate"}] }`;
    const userPrompt = `Break down this task: "${rawTask}"`;
    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiKey}`
        },
        body: JSON.stringify({
          model: "gpt-3.5-turbo",
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: userPrompt }
          ],
          temperature: 0.7,
          max_tokens: 800
        })
      });
      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }
      const data = await response.json();
      const content = (_b = (_a = data.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content;
      if (!content)
        throw new Error("No content from OpenAI");
      const parsed = JSON.parse(content);
      return {
        motivation: parsed.motivation || "AI-powered breakdown ready!",
        steps: (parsed.steps || []).map((s, i) => ({
          id: `ai-step-${i}`,
          title: s.title,
          description: s.description || "",
          estimatedMinutes: s.estimatedMinutes || 10,
          complexity: s.complexity || "simple",
          tips: s.tips || []
        }))
      };
    } catch (e) {
      console.error("OpenAI breakdown error:", e);
      throw e;
    }
  }
  /**
   * Fallback breakdown when AI services are unavailable
   */
  getFallbackBreakdown(rawTask, depth) {
    const baseSteps = [
      { title: `Clarify goal for: ${rawTask}`, description: "Write one sentence outcome", estimatedMinutes: 5, complexity: "micro" },
      { title: "List 3 sub-points", description: "Low-friction brain dump", estimatedMinutes: 8, complexity: "micro" },
      { title: "Start with easiest sub-point", description: "Momentum first", estimatedMinutes: 12, complexity: "simple" }
    ];
    if (depth >= 4) {
      return {
        motivation: "Ultra-detailed fallback breakdown",
        steps: [
          { title: `Open relevant document for: ${rawTask}`, description: "Just open the file", estimatedMinutes: 2, complexity: "micro" },
          { title: "Read first paragraph", description: "Orient yourself", estimatedMinutes: 3, complexity: "micro" },
          { title: "Write one bullet point", description: "Any bullet point", estimatedMinutes: 5, complexity: "micro" },
          { title: "Write second bullet point", description: "Build momentum", estimatedMinutes: 5, complexity: "micro" },
          { title: "Connect the two points", description: "Add transition", estimatedMinutes: 8, complexity: "simple" }
        ]
      };
    }
    return {
      motivation: "Fallback breakdown \u2013 try connecting to OpenAI for better results.",
      steps: baseSteps
    };
  }
  /**
   * AI-powered clarifying questions using OpenAI
   */
  async generateAIClarifyingQuestions(taskTitle, context) {
    var _a, _b;
    const systemPrompt = `You are an ADHD-aware task clarification assistant. Generate 3-4 smart clarifying questions that help break down vague or complex tasks into actionable steps. Focus on:
- Specific outcomes and deliverables
- Context and constraints  
- Dependencies and prerequisites
- Success criteria
- Time and energy considerations

Keep questions short, direct, and helpful for someone with ADHD who may struggle with task initiation.`;
    const userPrompt = `Task: "${taskTitle}"
${context ? `Additional context: ${context}` : ""}

Generate 3-4 clarifying questions that would help make this task more actionable and specific.`;
    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiKey}`
        },
        body: JSON.stringify({
          model: "gpt-3.5-turbo",
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: userPrompt }
          ],
          temperature: 0.8,
          max_tokens: 400
        })
      });
      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }
      const data = await response.json();
      const content = (_b = (_a = data.choices[0]) == null ? void 0 : _a.message) == null ? void 0 : _b.content;
      if (!content)
        throw new Error("No content from OpenAI");
      const questions = content.split("\n").filter((line) => line.trim() && (line.includes("?") || line.match(/^\d+\./))).map((line) => line.replace(/^\d+\.\s*/, "").replace(/^[-]\s*/, "").trim()).filter((q) => q.endsWith("?")).slice(0, 4);
      return questions.length > 0 ? questions : this.getFallbackClarifyingQuestions(taskTitle);
    } catch (e) {
      console.error("AI clarifying questions error:", e);
      throw e;
    }
  }
  /**
   * Fallback rule-based clarifying questions
   */
  getFallbackClarifyingQuestions(taskTitle) {
    const questions = [];
    if (taskTitle.split(" ").length < 4) {
      questions.push("What specific outcome do you want from this task?");
    }
    if (!/[A-Z]/.test(taskTitle.charAt(0))) {
      questions.push("Should this start with an action verb (e.g., Draft, Outline, Analyze)?");
    }
    if (!/(write|draft|outline|analy|review|collect|organize|refactor|summari|read)/i.test(taskTitle)) {
      questions.push("Which action verb best describes this task?");
    }
    questions.push('What would "done" look like in one sentence?');
    if (taskTitle.length > 60) {
      questions.push("Can this be split into smaller independent parts?");
    }
    return [...new Set(questions)].slice(0, 4);
  }
  /**
   * Add a task to the vault (usually in daily notes)
   */
  async addTaskToVault(taskTitle, priority = "normal") {
    const dailyNotePath = await this.getDailyNotePath();
    if (!dailyNotePath)
      return;
    try {
      const file = this.app.vault.getAbstractFileByPath(dailyNotePath);
      let content = "";
      if (file) {
        content = await this.app.vault.read(file);
      } else {
        content = `# ${new Date().toDateString()}

## Tasks

`;
      }
      const taskLine = `- [ ] ${taskTitle}`;
      const priorityMarker = priority === "high" ? " !!!" : priority === "low" ? " !" : "";
      const newTaskLine = `${taskLine}${priorityMarker}
`;
      if (content.includes("## Tasks")) {
        content = content.replace("## Tasks\n", `## Tasks
${newTaskLine}`);
      } else {
        content += `
## Tasks
${newTaskLine}`;
      }
      if (file) {
        await this.app.vault.modify(file, content);
      } else {
        await this.app.vault.create(dailyNotePath, content);
      }
      console.log(`Task added to vault: ${taskTitle}`);
    } catch (error) {
      console.error("Failed to add task to vault:", error);
      throw error;
    }
  }
  /**
   * Mark a task as completed
   */
  async completeTask(taskTitle) {
    const dailyNotePath = await this.getDailyNotePath();
    if (!dailyNotePath)
      return;
    try {
      const file = this.app.vault.getAbstractFileByPath(dailyNotePath);
      if (!file)
        return;
      const content = await this.app.vault.read(file);
      const updatedContent = content.replace(
        new RegExp(`- \\[ \\] ${taskTitle.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}`, "g"),
        `- [x] ${taskTitle}`
      );
      await this.app.vault.modify(file, updatedContent);
      console.log(`Task completed: ${taskTitle}`);
    } catch (error) {
      console.error("Failed to complete task:", error);
      throw error;
    }
  }
  /**
   * Get today's tasks from daily note
   */
  async getTodaysTasks() {
    const dailyNotePath = await this.getDailyNotePath();
    if (!dailyNotePath)
      return [];
    try {
      const file = this.app.vault.getAbstractFileByPath(dailyNotePath);
      if (!file)
        return [];
      const content = await this.app.vault.read(file);
      const tasks = [];
      const taskRegex = /^- \[([ x])\] (.+)$/gm;
      let match;
      while ((match = taskRegex.exec(content)) !== null) {
        const completed = match[1] === "x";
        const title = match[2];
        const priorityMatch = title.match(/(.+?)\s*(!{1,3})$/);
        const cleanTitle = priorityMatch ? priorityMatch[1] : title;
        const priority = priorityMatch ? priorityMatch[2] === "!!!" ? "high" : priorityMatch[2] === "!" ? "low" : "normal" : "normal";
        tasks.push({
          id: `task-${Date.now()}-${tasks.length}`,
          title: cleanTitle,
          completed,
          priority,
          source: "daily-note",
          estimatedMinutes: 25
          // default estimate
        });
      }
      return tasks;
    } catch (error) {
      console.error("Failed to get today's tasks:", error);
      return [];
    }
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  apiKey: "",
  serverUrl: "http://localhost:3001",
  enableProactiveNotifications: true,
  maxDailyNotifications: 12,
  defaultBreakdownDepth: 3,
  enablePatternDetection: true,
  enableHyperfocusProtection: true,
  procrastinationThreshold: 30,
  energyCheckInterval: 120,
  browserExtensionSync: {
    enableSync: true,
    syncInterval: 5,
    // minutes
    lastSyncTimestamp: 0,
    syncTasks: true,
    syncEnergyLevels: true,
    syncFocusSessions: true,
    syncEnforcementSettings: true
  },
  enforcement: {
    enableStrictMode: false,
    blockAllWebsites: false,
    requireDailyTaskCompletion: false,
    allowedDomains: ["localhost", "obsidian.md", "github.com"],
    enforcementStartTime: "09:00",
    enforcementEndTime: "17:00"
  },
  obsidianIntegration: {
    enableTaskSync: true,
    enableProgressTracking: true,
    enableSmartLinking: true,
    dissertationFolderPath: "Dissertation",
    dailyNotePath: "Daily Notes",
    taskTagPrefix: "#proactivity"
  },
  adhdSupport: {
    useGentleTone: true,
    includeMotivation: true,
    limitCognitiveLoad: true,
    enableBodyDoubling: false,
    timeBlindnessSupport: true
  }
};
var ProactivityPlugin = class extends import_obsidian6.Plugin {
  async onload() {
    try {
      await this.loadSettings();
      this.integrationService = new ObsidianIntegrationService(this.app, this.settings);
      this.patternDetector = new ADHDPatternDetector(this.app, this.settings);
      this.statusBarItem = this.addStatusBarItem();
      this.updateStatusBar("Initializing...");
      await this.testBackendConnection();
      this.registerView(
        VIEW_TYPE_PROACTIVITY,
        (leaf) => new ProactivityView(leaf, this.settings, this.integrationService)
      );
      this.addRibbonIcon("brain", "Proactivity", () => {
        this.activateView();
      });
      this.updateStatusBar("Ready");
      this.registerCommands();
      if (this.settings.enablePatternDetection) {
        this.patternDetector.startDetection();
      }
      if (this.settings.enableProactiveNotifications) {
        this.startProactiveNotifications();
      }
      if (this.settings.browserExtensionSync.enableSync) {
        this.startBrowserExtensionSync();
      }
      this.addSettingTab(new ProactivitySettingTab(this.app, this));
      new import_obsidian6.Notice("Proactivity: Your ADHD-friendly dissertation assistant is ready!");
      window.Proactivity = {
        ctx: () => this.integrationService.getCurrentContext(),
        suggestions: (lvl) => this.integrationService.getTaskSuggestions(lvl || "moderate"),
        celebrate: () => this.celebrateProgress(),
        sync: () => this.syncWithBrowserExtension(),
        getUrgentTasks: () => this.getUrgentTasks()
      };
    } catch (error) {
      console.error("Proactivity Plugin: Failed to initialize:", error);
      new import_obsidian6.Notice("\u274C Proactivity Plugin failed to load. Check console for details.", 8e3);
      this.statusBarItem = this.addStatusBarItem();
      this.updateStatusBar("Error - check console");
    }
  }
  async testBackendConnection() {
    try {
      const response = await fetch(`${this.settings.serverUrl}/health`);
      if (response.ok) {
        const health = await response.json();
        new import_obsidian6.Notice(`\u2705 Connected to Proactivity backend (v${health.version || "1.0.0"})`, 3e3);
        this.updateStatusBar("Connected");
      } else {
        throw new Error("Backend health check failed");
      }
    } catch (error) {
      console.warn("Backend connection failed:", error);
      new import_obsidian6.Notice("\u26A0\uFE0F Backend offline - using local mode. Task breakdown will use fallback.", 6e3);
      this.updateStatusBar("Offline mode");
    }
  }
  // Browser Extension Sync Methods
  startBrowserExtensionSync() {
    console.log("Starting browser extension sync...");
    this.syncWithBrowserExtension();
    const syncIntervalMs = this.settings.browserExtensionSync.syncInterval * 60 * 1e3;
    this.syncInterval = setInterval(() => {
      this.syncWithBrowserExtension();
    }, syncIntervalMs);
  }
  async syncWithBrowserExtension() {
    if (!this.settings.browserExtensionSync.enableSync) {
      return;
    }
    try {
      const syncData = {
        timestamp: Date.now(),
        tasks: await this.getObsidianTasks(),
        energyLevel: await this.getCurrentEnergyLevel(),
        focusSessions: await this.getFocusSessions(),
        enforcementSettings: this.settings.enforcement
      };
      localStorage.setItem("proactivity-obsidian-sync", JSON.stringify(syncData));
      try {
        if (typeof window !== "undefined" && window.chrome && window.chrome.runtime) {
          window.chrome.runtime.sendMessage("your-extension-id", {
            action: "syncFromObsidian",
            data: syncData
          });
        }
      } catch (extError) {
      }
      this.settings.browserExtensionSync.lastSyncTimestamp = Date.now();
      await this.saveSettings();
      console.log("Browser extension sync completed successfully");
    } catch (error) {
      console.error("Browser extension sync failed:", error);
    }
  }
  async getObsidianTasks() {
    const files = this.app.vault.getMarkdownFiles();
    const tasks = [];
    for (const file of files) {
      const content = await this.app.vault.read(file);
      const taskRegex = /- \[[ x]\] (.+?)(?:\n|$)/g;
      let match;
      while ((match = taskRegex.exec(content)) !== null) {
        const isCompleted = match[0].includes("[x]");
        const taskText = match[1].trim();
        const priorityMatch = taskText.match(/\!{1,3}/);
        let priority = "medium";
        if (priorityMatch) {
          priority = priorityMatch[0].length === 3 ? "high" : priorityMatch[0].length === 2 ? "medium" : "low";
        }
        tasks.push({
          id: `obsidian-${file.path}-${match.index}`,
          title: taskText.replace(/\!{1,3}\s*/, ""),
          // Remove priority markers
          completed: isCompleted,
          priority,
          source: "obsidian",
          filePath: file.path,
          createdAt: new Date(file.stat.ctime).toISOString(),
          modifiedAt: new Date(file.stat.mtime).toISOString()
        });
      }
    }
    return tasks;
  }
  async getCurrentEnergyLevel() {
    const today = new Date().toISOString().split("T")[0];
    const dailyNotePath = `${this.settings.obsidianIntegration.dailyNotePath}/${today}.md`;
    try {
      const dailyNote = this.app.vault.getAbstractFileByPath(dailyNotePath);
      if (dailyNote instanceof import_obsidian6.TFile) {
        const content = await this.app.vault.read(dailyNote);
        const energyMatch = content.match(/energy:\s*(\d+)/i);
        if (energyMatch) {
          return parseInt(energyMatch[1]);
        }
      }
    } catch (error) {
    }
    return 3;
  }
  async getFocusSessions() {
    return [];
  }
  async getUrgentTasks() {
    const tasks = await this.getObsidianTasks();
    return tasks.filter((task) => !task.completed).map((task) => ({
      ...task,
      urgencyScore: this.calculateUrgencyScore(task)
    })).sort((a, b) => b.urgencyScore - a.urgencyScore).slice(0, 5);
  }
  calculateUrgencyScore(task) {
    let score = 0;
    const priorityWeights = { high: 50, medium: 30, low: 10 };
    score += priorityWeights[task.priority] || 20;
    const daysSinceCreated = (Date.now() - new Date(task.createdAt).getTime()) / (1e3 * 60 * 60 * 24);
    score += Math.min(daysSinceCreated * 5, 30);
    if (task.filePath.includes("daily") || task.filePath.includes("today")) {
      score += 20;
    }
    if (task.title.toLowerCase().includes("urgent") || task.title.includes("!!!")) {
      score += 25;
    }
    return score;
  }
  onunload() {
    var _a;
    if (this.notificationInterval) {
      clearInterval(this.notificationInterval);
    }
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
    }
    (_a = this.patternDetector) == null ? void 0 : _a.stopDetection();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    var _a, _b;
    await this.saveData(this.settings);
    (_a = this.integrationService) == null ? void 0 : _a.updateSettings(this.settings);
    (_b = this.patternDetector) == null ? void 0 : _b.updateSettings(this.settings);
  }
  registerCommands() {
    this.addCommand({
      id: "breakdown-current-task",
      name: "Break down current task",
      callback: () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          this.openTaskBreakdownModal(activeFile);
        } else {
          new import_obsidian6.Notice("Please open a file or select text to break down");
        }
      }
    });
    this.addCommand({
      id: "energy-check",
      name: "Quick energy level check",
      callback: () => {
        this.showEnergyCheckModal();
      }
    });
    this.addCommand({
      id: "start-focus-session",
      name: "Start focused work session",
      callback: () => {
        this.startFocusSession();
      }
    });
    this.addCommand({
      id: "procrastination-help",
      name: "Help! I'm procrastinating",
      callback: () => {
        this.triggerProcrastinationIntervention();
      }
    });
    this.addCommand({
      id: "celebrate-progress",
      name: "Celebrate progress made",
      callback: () => {
        this.celebrateProgress();
      }
    });
    this.addCommand({
      id: "vacation-mode",
      name: "Start vacation mode",
      callback: () => {
        new import_obsidian6.Notice("Vacation mode activated. Enjoy your break! \u{1F3D6}\uFE0F");
      }
    });
    this.addCommand({
      id: "deep-focus-mode",
      name: "Start deep focus mode",
      callback: () => {
        new import_obsidian6.Notice("Deep focus mode activated. \u{1F3AF}");
      }
    });
    this.addCommand({
      id: "end-out-of-office",
      name: "End out of office mode",
      callback: () => {
        new import_obsidian6.Notice("Welcome back! All features restored. \u2728");
      }
    });
    this.addCommand({
      id: "goblin-mode-breakdown",
      name: "Goblin Mode: Break down tasks in current file",
      callback: async () => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
        if (!view) {
          new import_obsidian6.Notice("Open a markdown file");
          return;
        }
        const editor = view.editor;
        const selection = editor.getSelection() || editor.getValue();
        const tasks = this.integrationService.parseTasksFromText(selection);
        if (!tasks.length) {
          new import_obsidian6.Notice("No markdown tasks found (- [ ] )");
          return;
        }
        class GoblinModeModal extends import_obsidian6.Modal {
          // Track breakdown depth per task
          constructor(app, plugin, tasksParsed) {
            super(app);
            this.taskDepths = {};
            this.plugin = plugin;
            this.tasksParsed = tasksParsed;
            this.tasksParsed.forEach((t) => this.taskDepths[t.title] = 2);
          }
          onOpen() {
            const { contentEl } = this;
            contentEl.empty();
            contentEl.addClass("goblin-modal");
            const style = contentEl.createEl("style");
            style.textContent = `
              .goblin-modal {
                max-width: 800px !important;
                max-height: 80vh !important;
                overflow-y: auto;
              }
              .goblin-tips {
                background: var(--background-secondary);
                padding: 12px;
                border-radius: 6px;
                margin: 16px 0;
                font-size: 0.9em;
              }
              .goblin-tips li {
                margin: 6px 0;
                list-style: none;
                padding-left: 16px;
                position: relative;
              }
              .goblin-tips li:before {
                content: "\u{1F4A1}";
                position: absolute;
                left: 0;
              }
              .goblin-task-row {
                border: 1px solid var(--background-modifier-border);
                border-radius: 8px;
                padding: 16px;
                margin: 12px 0;
                background: var(--background-primary);
              }
              .goblin-task-title {
                font-weight: 600;
                margin-bottom: 12px;
                color: var(--text-accent);
                font-size: 1.1em;
              }
              .goblin-task-controls {
                display: flex;
                gap: 8px;
                margin-bottom: 12px;
                flex-wrap: wrap;
              }
              .goblin-task-controls button {
                padding: 6px 12px;
                border-radius: 4px;
                font-size: 0.9em;
              }
              .goblin-clarify-box {
                background: var(--background-secondary);
                padding: 12px;
                border-radius: 6px;
                margin: 12px 0;
              }
              .goblin-clarify-box p {
                margin: 6px 0;
              }
              .clarify-input {
                width: 100%;
                min-height: 60px;
                margin: 8px 0;
                padding: 8px;
                border-radius: 4px;
                resize: vertical;
              }
              .goblin-steps {
                background: var(--background-secondary);
                padding: 16px;
                border-radius: 8px;
                margin-top: 12px;
              }
              .goblin-step {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 8px 0;
                border-bottom: 1px solid var(--background-modifier-border);
              }
              .goblin-step:last-child {
                border-bottom: none;
              }
              .goblin-step-text {
                flex: 1;
                margin-right: 12px;
              }
              .step-add-btn, .step-breakdown-btn {
                padding: 4px 8px;
                font-size: 0.8em;
                margin-left: 4px;
              }
              .goblin-step-controls {
                display: flex;
                gap: 4px;
                align-items: center;
              }
              .goblin-footer {
                margin-top: 24px;
                padding-top: 16px;
                border-top: 1px solid var(--background-modifier-border);
                display: flex;
                gap: 12px;
                justify-content: space-between;
                flex-wrap: wrap;
              }
            `;
            contentEl.createEl("h2", { text: "\u{1F9CC} Goblin Mode: AI Task Breakdown" });
            contentEl.createEl("p", { text: "AI-powered iterative task breakdown. Use Clarify to get smart questions and provide context, then Break Down for AI steps that get more granular with each click!" });
            const tips = contentEl.createEl("ul", { cls: "goblin-tips" });
            tips.createEl("li", { text: "AI Clarify generates smart questions specific to each task" });
            tips.createEl("li", { text: "Your clarify answers feed into AI breakdowns for better context" });
            tips.createEl("li", { text: 'Each "Break Down" click makes steps more specific and granular' });
            tips.createEl("li", { text: "Break down individual AI-generated steps for ultra-fine detail" });
            const listEl = contentEl.createEl("div", { cls: "goblin-task-list" });
            const answers = {};
            this.tasksParsed.forEach((t, taskIndex) => {
              this.renderTaskRow(t, taskIndex, listEl, answers);
            });
            const footer = contentEl.createEl("div", { cls: "goblin-footer" });
            const addAllTasksBtn = footer.createEl("button", { text: "\u{1F4E5} Add All Generated Steps", cls: "mod-cta" });
            addAllTasksBtn.onclick = async () => {
              await this.addAllGeneratedSteps();
            };
            const doneBtn = footer.createEl("button", { text: "Close", cls: "secondary-btn" });
            doneBtn.onclick = () => this.close();
          }
          renderTaskRow(t, taskIndex, listEl, answers) {
            const row = listEl.createEl("div", { cls: "goblin-task-row" });
            row.createEl("div", { text: t.title, cls: "goblin-task-title" });
            const controls = row.createEl("div", { cls: "goblin-task-controls" });
            const qBtn = controls.createEl("button", { text: "\u2753 Clarify", cls: "mod-cta" });
            qBtn.onclick = () => {
              this.showClarifyBox(row, t, taskIndex, answers);
            };
            const currentDepth = this.taskDepths[t.title] || 2;
            const depthLabel = currentDepth === 2 ? "Break Down" : currentDepth === 3 ? "Break Down (Detailed)" : currentDepth === 4 ? "Break Down (Micro)" : "Break Down (Ultra-Fine)";
            const bBtn = controls.createEl("button", { text: `\u{1F528} ${depthLabel}`, cls: "mod-cta" });
            bBtn.onclick = async () => {
              await this.breakdownTask(row, t, answers);
            };
          }
          showClarifyBox(row, t, taskIndex, answers) {
            const boxId = `clarify-box-${taskIndex}`;
            if (row.querySelector(`#${boxId}`))
              return;
            const qbox = row.createEl("div", { cls: "goblin-clarify-box", attr: { id: boxId } });
            const loadingEl = qbox.createEl("p", { text: "\u{1F916} Generating smart questions...", cls: "muted" });
            this.plugin.integrationService.generateClarifyingQuestions(t.title).then((qs) => {
              loadingEl.remove();
              qbox.createEl("p", { text: "AI-generated clarifying questions:", cls: "small" });
              qs.forEach((q) => qbox.createEl("p", { text: "\u2022 " + q, cls: "tiny" }));
              const input = qbox.createEl("textarea", { cls: "clarify-input", placeholder: "Answer one or more questions above (be specific but concise)..." });
              const buttonsEl = qbox.createEl("div", { cls: "goblin-task-controls" });
              const saveBtn = buttonsEl.createEl("button", { text: "\u{1F4BE} Save Context", cls: "mod-cta" });
              saveBtn.onclick = () => {
                const val = input.value.trim();
                if (!val) {
                  new import_obsidian6.Notice("Please provide some context for better AI breakdowns");
                  return;
                }
                answers[t.title] = answers[t.title] || [];
                answers[t.title].push(val);
                qbox.createEl("p", { text: "\u2713 Context saved: " + val, cls: "tiny muted" });
                input.value = "";
                new import_obsidian6.Notice("Context saved! This will improve your next breakdown.");
              };
              const closeBtn = buttonsEl.createEl("button", { text: "Close", cls: "secondary-btn" });
              closeBtn.onclick = () => qbox.remove();
            }).catch((err) => {
              loadingEl.textContent = "\u26A0\uFE0F AI questions unavailable - using fallback";
              console.error("AI clarifying questions failed", err);
              const fallbackQuestions = [
                "What specific outcome do you want?",
                'What would "done" look like?',
                "Any constraints or requirements?",
                "How much time do you have?"
              ];
              fallbackQuestions.forEach((q) => qbox.createEl("p", { text: "\u2022 " + q, cls: "tiny" }));
              const input = qbox.createEl("textarea", { cls: "clarify-input", placeholder: "Answer one or more questions above..." });
              const buttonsEl = qbox.createEl("div", { cls: "goblin-task-controls" });
              const saveBtn = buttonsEl.createEl("button", { text: "\u{1F4BE} Save Context", cls: "mod-cta" });
              saveBtn.onclick = () => {
                const val = input.value.trim();
                if (!val) {
                  new import_obsidian6.Notice("Please provide some context");
                  return;
                }
                answers[t.title] = answers[t.title] || [];
                answers[t.title].push(val);
                qbox.createEl("p", { text: "\u2713 Context saved: " + val, cls: "tiny muted" });
                input.value = "";
              };
              const closeBtn = buttonsEl.createEl("button", { text: "Close", cls: "secondary-btn" });
              closeBtn.onclick = () => qbox.remove();
            });
          }
          async breakdownTask(row, t, answers) {
            const existingSteps = row.querySelector(".goblin-steps");
            if (existingSteps)
              existingSteps.remove();
            const spinner = row.createEl("span", { text: " \u{1F916} AI thinking...", cls: "muted" });
            try {
              const currentDepth = this.taskDepths[t.title] || 2;
              const context = answers[t.title] ? answers[t.title].join(". ") : "";
              const result = await this.plugin.integrationService.breakdownTask(t.title, {
                energyLevel: "moderate",
                depth: currentDepth,
                context
              });
              this.taskDepths[t.title] = Math.min(currentDepth + 1, 6);
              const nextDepth = this.taskDepths[t.title];
              const bBtn = row.querySelector(".goblin-task-controls button:last-child");
              if (bBtn) {
                const nextLabel = nextDepth === 3 ? "Break Down (Detailed)" : nextDepth === 4 ? "Break Down (Micro)" : nextDepth >= 5 ? "Break Down (Ultra-Fine)" : "Break Down";
                bBtn.textContent = `\u{1F528} ${nextLabel}`;
              }
              this.renderSteps(row, result, t.title);
            } catch (err) {
              console.error("Breakdown error", err);
              new import_obsidian6.Notice("AI breakdown failed - check your OpenAI API key in settings");
            } finally {
              spinner.remove();
            }
          }
          renderSteps(row, result, taskTitle) {
            const stepsEl = row.createEl("div", { cls: "goblin-steps" });
            if (result.motivation)
              stepsEl.createEl("p", { text: result.motivation, cls: "tiny muted" });
            result.steps.forEach((s, i) => {
              const li = stepsEl.createEl("div", { cls: "goblin-step", attr: { "data-ai": "true" } });
              li.createEl("span", { text: `\u2022 ${s.title} (${s.estimatedMinutes}m)`, cls: "goblin-step-text" });
              const controls = li.createEl("div", { cls: "goblin-step-controls" });
              const addBtn = controls.createEl("button", { text: "+ Add", cls: "step-add-btn mod-cta" });
              addBtn.onclick = () => {
                this.addStepToFile(s);
              };
              const breakdownBtn = controls.createEl("button", { text: "\u{1F528}", cls: "step-breakdown-btn" });
              breakdownBtn.title = "Break down this step with AI for more detail";
              breakdownBtn.onclick = async () => {
                await this.breakdownIndividualStep(li, s);
              };
            });
            const addAllBtn = stepsEl.createEl("button", { text: "\u{1F4CB} Add All AI Steps", cls: "mod-cta", attr: { style: "margin-top: 12px;" } });
            addAllBtn.onclick = () => {
              this.addAllStepsForTask(result.steps);
            };
          }
          async breakdownIndividualStep(stepEl, step) {
            const spinner = stepEl.createEl("span", { text: " \u{1F916}", cls: "muted" });
            try {
              const result = await this.plugin.integrationService.breakdownTask(step.title, {
                energyLevel: "moderate",
                depth: 4,
                // Always go deep for individual steps
                context: step.description
              });
              const subStepsEl = stepEl.createEl("div", { cls: "goblin-substeps", attr: { style: "margin-left: 20px; margin-top: 8px; padding: 8px; background: var(--background-primary); border-radius: 4px;" } });
              result.steps.forEach((subStep) => {
                const subLi = subStepsEl.createEl("div", { cls: "goblin-substep", attr: { style: "display: flex; justify-content: space-between; align-items: center; padding: 4px 0; font-size: 0.9em;" } });
                subLi.createEl("span", { text: `  \u25E6 ${subStep.title} (${subStep.estimatedMinutes}m)` });
                const addSubBtn = subLi.createEl("button", { text: "+ Add", cls: "step-add-btn", attr: { style: "font-size: 0.8em; padding: 2px 6px;" } });
                addSubBtn.onclick = () => {
                  this.addStepToFile(subStep);
                };
              });
            } catch (err) {
              console.error("Sub-breakdown error", err);
              new import_obsidian6.Notice("Failed to break down step further");
            } finally {
              spinner.remove();
            }
          }
          addStepToFile(step) {
            const view2 = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
            if (view2) {
              const editor2 = view2.editor;
              const insertion = `    - [ ] ${step.title} (${step.estimatedMinutes}min)`;
              editor2.replaceSelection(editor2.getSelection() + "\n" + insertion + "\n");
              new import_obsidian6.Notice("Step added to file");
            }
          }
          addAllStepsForTask(steps) {
            const view2 = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
            if (view2) {
              const editor2 = view2.editor;
              const insertion = steps.map((s) => `    - [ ] ${s.title} (${s.estimatedMinutes}min)`).join("\n");
              editor2.replaceSelection(editor2.getSelection() + "\n" + insertion + "\n");
              new import_obsidian6.Notice("All steps added for task");
            }
          }
          async addAllGeneratedSteps() {
            const view2 = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
            if (!view2) {
              new import_obsidian6.Notice("Open a markdown file to insert into");
              return;
            }
            const editor2 = view2.editor;
            const allSteps = this.contentEl.querySelectorAll(".goblin-step-text");
            if (allSteps.length === 0) {
              new import_obsidian6.Notice("No steps generated yet - try breaking down some tasks first");
              return;
            }
            let insertion = "";
            allSteps.forEach((stepEl) => {
              const text = stepEl.textContent;
              if (text) {
                insertion += "\n    - [ ] " + text;
              }
            });
            editor2.replaceSelection(editor2.getSelection() + insertion + "\n");
            new import_obsidian6.Notice(`Added ${allSteps.length} generated steps to file`);
          }
          onClose() {
            const { contentEl } = this;
            contentEl.empty();
          }
        }
        const modal = new GoblinModeModal(this.app, this, tasks);
        modal.open();
      }
    });
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_PROACTIVITY);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: VIEW_TYPE_PROACTIVITY, active: true }));
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  openTaskBreakdownModal(file) {
    const modal = new TaskBreakdownModal(
      this.app,
      this.settings,
      this.integrationService,
      file
    );
    modal.open();
  }
  showEnergyCheckModal() {
    const modal = new class extends import_obsidian6.Modal {
      constructor(app, plugin) {
        super(app);
        this.plugin = plugin;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.createEl("h2", { text: "Energy Level Check" });
        const description = contentEl.createEl("p", {
          text: "How's your energy and focus right now? This helps me suggest appropriate tasks."
        });
        const energyLevels = [
          { level: "high", label: "\u26A1 High - Ready for complex tasks", color: "#22c55e" },
          { level: "moderate", label: "\u{1F50B} Moderate - Normal capacity", color: "#3b82f6" },
          { level: "low", label: "\u{1FAAB} Low - Simple tasks only", color: "#f59e0b" },
          { level: "depleted", label: "\u{1F634} Depleted - Need rest/micro-tasks", color: "#ef4444" }
        ];
        energyLevels.forEach(({ level, label, color }) => {
          const button = contentEl.createEl("button", {
            text: label,
            cls: "mod-cta energy-level-button"
          });
          button.style.backgroundColor = color;
          button.style.margin = "10px 0";
          button.style.width = "100%";
          button.onclick = async () => {
            await this.plugin.handleEnergyLevelUpdate(level);
            this.close();
          };
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app, this);
    modal.open();
  }
  async handleEnergyLevelUpdate(energyLevel) {
    this.updateStatusBar(`Energy: ${energyLevel}`);
    await this.integrationService.updateEnergyLevel(energyLevel);
    const suggestions = await this.integrationService.getTaskSuggestions(energyLevel);
    if (suggestions && suggestions.length > 0) {
      new import_obsidian6.Notice(`Based on your ${energyLevel} energy, I suggest: ${suggestions[0].title}`);
    }
  }
  startFocusSession() {
    const sessionLength = 25;
    new import_obsidian6.Notice(`Starting ${sessionLength}-minute focus session. I'll check in periodically.`);
    this.updateStatusBar("\u{1F3AF} Focusing");
    const checkInInterval = setInterval(() => {
      this.patternDetector.checkFocusState();
    }, 10 * 60 * 1e3);
    setTimeout(() => {
      clearInterval(checkInInterval);
      new import_obsidian6.Notice("Focus session complete! Great job. Time for a break?");
      this.updateStatusBar("\u2705 Session done");
    }, sessionLength * 60 * 1e3);
  }
  async triggerProcrastinationIntervention() {
    new import_obsidian6.Notice("I'm here to help! Let's break through this together.");
    const activeFile = this.app.workspace.getActiveFile();
    const selectedText = await this.integrationService.getSelectedText();
    this.openTaskBreakdownModal(activeFile);
    this.updateStatusBar("\u{1F91D} Body doubling active");
  }
  celebrateProgress() {
    const celebrations = [
      "\u{1F389} Amazing work! Every step counts.",
      "\u{1F44F} You're making real progress!",
      "\u2B50 Your persistence is paying off!",
      "\u{1F680} Look at you, crushing it!",
      "\u{1F4AA} Your ADHD brain is powerful!"
    ];
    const celebration = celebrations[Math.floor(Math.random() * celebrations.length)];
    new import_obsidian6.Notice(celebration);
    this.integrationService.logProgressCelebration();
  }
  startProactiveNotifications() {
    this.notificationInterval = setInterval(async () => {
      const shouldNotify = await this.shouldSendProactiveNotification();
      if (shouldNotify) {
        await this.sendContextualNotification();
      }
    }, this.settings.energyCheckInterval * 60 * 1e3);
  }
  async shouldSendProactiveNotification() {
    const patterns = await this.patternDetector.getCurrentPatterns();
    const isInHyperfocus = patterns.some((p) => p.type === "hyperfocus");
    const userActivity = await this.integrationService.getUserActivity();
    if (isInHyperfocus) {
      return patterns.some((p) => p.healthConcern);
    }
    const recentNotifications = this.integrationService.getRecentNotificationCount();
    if (recentNotifications >= 3) {
      return false;
    }
    return userActivity.seemsStuck || userActivity.inactiveForMinutes > 45;
  }
  async sendContextualNotification() {
    const context = await this.integrationService.getCurrentContext();
    const notification = await this.generateContextualNotification(context);
    if (notification) {
      new import_obsidian6.Notice(notification.message);
      if (notification.action) {
        setTimeout(() => {
          this[notification.action]();
        }, 5e3);
      }
    }
  }
  async generateContextualNotification(context) {
    if (context.hasUnfinishedTasks && context.energyLevel !== "depleted") {
      return {
        message: "I noticed some tasks in progress. Want to tackle one together?",
        action: "activateView"
      };
    }
    if (context.inactiveForMinutes > 60) {
      return {
        message: "How's your dissertation work going today? Any goals you'd like to set?",
        action: "showEnergyCheckModal"
      };
    }
    return null;
  }
  updateStatusBar(status) {
    if (this.statusBarItem) {
      this.statusBarItem.setText(`Proactivity: ${status}`);
    }
  }
};
var ProactivitySettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Proactivity Settings" });
    containerEl.createEl("h3", { text: "API Configuration" });
    containerEl.createEl("p", {
      text: "\u{1F916} For AI-powered task breakdowns in Goblin Mode, add your OpenAI API key below. Without this, you'll get basic fallback breakdowns.",
      cls: "setting-item-description"
    });
    new import_obsidian6.Setting(containerEl).setName("OpenAI API Key").setDesc("Get your API key from https://platform.openai.com/api-keys - enables smart task breakdown").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Server URL").setDesc("Proactivity backend server URL (optional - OpenAI direct is preferred)").addText((text) => text.setPlaceholder("http://localhost:3001").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
      this.plugin.settings.serverUrl = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "ADHD Support Features" });
    new import_obsidian6.Setting(containerEl).setName("Enable Proactive Notifications").setDesc("Receive gentle, context-aware notifications and check-ins").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableProactiveNotifications).onChange(async (value) => {
      this.plugin.settings.enableProactiveNotifications = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Enable Pattern Detection").setDesc("Detect ADHD patterns like procrastination and hyperfocus").addToggle((toggle) => toggle.setValue(this.plugin.settings.enablePatternDetection).onChange(async (value) => {
      this.plugin.settings.enablePatternDetection = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Enable Hyperfocus Protection").setDesc("Get gentle reminders during extended work sessions").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableHyperfocusProtection).onChange(async (value) => {
      this.plugin.settings.enableHyperfocusProtection = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Max Daily Notifications").setDesc("Limit notifications to prevent overwhelm").addSlider((slider) => slider.setLimits(3, 20, 1).setValue(this.plugin.settings.maxDailyNotifications).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxDailyNotifications = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Obsidian Integration" });
    new import_obsidian6.Setting(containerEl).setName("Dissertation Folder Path").setDesc("Path to your dissertation notes folder").addText((text) => text.setPlaceholder("Dissertation").setValue(this.plugin.settings.obsidianIntegration.dissertationFolderPath).onChange(async (value) => {
      this.plugin.settings.obsidianIntegration.dissertationFolderPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Enable Smart Linking").setDesc("Automatically create connections between related notes").addToggle((toggle) => toggle.setValue(this.plugin.settings.obsidianIntegration.enableSmartLinking).onChange(async (value) => {
      this.plugin.settings.obsidianIntegration.enableSmartLinking = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Enable Progress Tracking").setDesc("Track your writing progress and patterns").addToggle((toggle) => toggle.setValue(this.plugin.settings.obsidianIntegration.enableProgressTracking).onChange(async (value) => {
      this.plugin.settings.obsidianIntegration.enableProgressTracking = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Browser Extension Sync" });
    containerEl.createEl("p", {
      text: "\u{1F504} Sync tasks, energy levels, and focus sessions with the Proactivity browser extension.",
      cls: "setting-item-description"
    });
    new import_obsidian6.Setting(containerEl).setName("Enable Browser Extension Sync").setDesc("Sync data with browser extension via localStorage and API").addToggle((toggle) => toggle.setValue(this.plugin.settings.browserExtensionSync.enableSync).onChange(async (value) => {
      this.plugin.settings.browserExtensionSync.enableSync = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.startBrowserExtensionSync();
      } else if (this.plugin.syncInterval) {
        clearInterval(this.plugin.syncInterval);
      }
    }));
    new import_obsidian6.Setting(containerEl).setName("Sync Interval (minutes)").setDesc("How often to sync with browser extension").addSlider((slider) => slider.setLimits(1, 30, 1).setValue(this.plugin.settings.browserExtensionSync.syncInterval).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.browserExtensionSync.syncInterval = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Sync Tasks").setDesc("Share tasks between Obsidian and browser extension").addToggle((toggle) => toggle.setValue(this.plugin.settings.browserExtensionSync.syncTasks).onChange(async (value) => {
      this.plugin.settings.browserExtensionSync.syncTasks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Sync Energy Levels").setDesc("Share energy level settings between platforms").addToggle((toggle) => toggle.setValue(this.plugin.settings.browserExtensionSync.syncEnergyLevels).onChange(async (value) => {
      this.plugin.settings.browserExtensionSync.syncEnergyLevels = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Productivity Enforcement" });
    containerEl.createEl("p", {
      text: "\u{1F512} Configure strict productivity enforcement to help maintain focus.",
      cls: "setting-item-description"
    });
    new import_obsidian6.Setting(containerEl).setName("Enable Strict Mode").setDesc("Block all websites until daily tasks are completed").addToggle((toggle) => toggle.setValue(this.plugin.settings.enforcement.enableStrictMode).onChange(async (value) => {
      this.plugin.settings.enforcement.enableStrictMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Block All Websites").setDesc("When strict mode is active, block all web browsing").addToggle((toggle) => toggle.setValue(this.plugin.settings.enforcement.blockAllWebsites).onChange(async (value) => {
      this.plugin.settings.enforcement.blockAllWebsites = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Require Daily Task Completion").setDesc("Unlock web browsing only after completing at least one task").addToggle((toggle) => toggle.setValue(this.plugin.settings.enforcement.requireDailyTaskCompletion).onChange(async (value) => {
      this.plugin.settings.enforcement.requireDailyTaskCompletion = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Allowed Domains").setDesc("Domains that remain accessible even in strict mode (comma-separated)").addTextArea((text) => text.setPlaceholder("localhost, obsidian.md, github.com").setValue(this.plugin.settings.enforcement.allowedDomains.join(", ")).onChange(async (value) => {
      this.plugin.settings.enforcement.allowedDomains = value.split(",").map((d) => d.trim());
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Enforcement Hours").setDesc("Active enforcement time range").addText((text) => text.setPlaceholder("09:00").setValue(this.plugin.settings.enforcement.enforcementStartTime).onChange(async (value) => {
      this.plugin.settings.enforcement.enforcementStartTime = value;
      await this.plugin.saveSettings();
    })).addText((text) => text.setPlaceholder("17:00").setValue(this.plugin.settings.enforcement.enforcementEndTime).onChange(async (value) => {
      this.plugin.settings.enforcement.enforcementEndTime = value;
      await this.plugin.saveSettings();
    }));
  }
};
