/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ProactivityPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/proactive-view.ts
var import_obsidian2 = require("obsidian");

// src/api-client.ts
var import_obsidian = require("obsidian");
var ProactivityApiClient = class {
  constructor(settings) {
    this.settings = settings;
    this.baseUrl = settings.serverUrl || "http://localhost:3001";
  }
  updateSettings(settings) {
    this.settings = settings;
    this.baseUrl = settings.serverUrl || "http://localhost:3001";
  }
  /**
   * Make HTTP request with error handling
   */
  async makeRequest(endpoint, options = {}) {
    const url = `${this.baseUrl}/api${endpoint}`;
    const defaultOptions = {
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      },
      ...options
    };
    try {
      const response = await fetch(url, defaultOptions);
      const data = await response.json();
      if (!response.ok) {
        const error = data;
        throw new Error(error.message || `HTTP ${response.status}: ${response.statusText}`);
      }
      return data;
    } catch (error) {
      if (error instanceof TypeError && error.message.includes("fetch")) {
        throw new Error("Unable to connect to Proactivity server. Please check that the backend is running.");
      }
      throw error;
    }
  }
  /**
   * Test connection to backend
   */
  async testConnection() {
    try {
      const response = await fetch(`${this.baseUrl}/health`);
      return response.ok;
    } catch (error) {
      return false;
    }
  }
  /**
   * Get health status from backend
   */
  async getHealth() {
    return this.makeRequest("/health");
  }
  /**
   * Break down a task into ADHD-friendly micro-tasks
   */
  async breakdownTask(request) {
    return this.makeRequest("/tasks/breakdown", {
      method: "POST",
      body: JSON.stringify(request)
    });
  }
  /**
   * Get task suggestions based on current context
   */
  async getTaskSuggestions(energyLevel = "moderate", availableTime = 30, category) {
    const params = new URLSearchParams({
      energyLevel,
      availableTime: availableTime.toString()
    });
    if (category) {
      params.append("category", category);
    }
    return this.makeRequest(`/tasks/suggestions?${params}`);
  }
  /**
   * Start tracking a task
   */
  async startTask(taskId, estimatedDuration) {
    return this.makeRequest("/tasks/start", {
      method: "POST",
      body: JSON.stringify({
        taskId,
        estimatedDuration,
        userId: "obsidian_user"
        // Could be made configurable
      })
    });
  }
  /**
   * Mark task as completed
   */
  async completeTask(taskId, actualDuration, difficulty, notes) {
    return this.makeRequest("/tasks/complete", {
      method: "POST",
      body: JSON.stringify({
        taskId,
        actualDuration,
        difficulty,
        notes,
        userId: "obsidian_user"
      })
    });
  }
  /**
   * Get task templates for common dissertation activities
   */
  async getTaskTemplates() {
    return this.makeRequest("/tasks/templates");
  }
  /**
   * Update user energy level
   */
  async updateEnergyLevel(energyLevel) {
    return this.makeRequest("/api/patterns/energy", {
      method: "POST",
      body: JSON.stringify({
        energyLevel,
        timestamp: new Date().toISOString(),
        userId: "obsidian_user"
      })
    });
  }
  /**
   * Record user activity for pattern detection
   */
  async recordActivity(activityType, data) {
    return this.makeRequest("/api/patterns/activity", {
      method: "POST",
      body: JSON.stringify({
        type: activityType,
        data,
        timestamp: new Date().toISOString(),
        userId: "obsidian_user"
      })
    });
  }
  /**
   * Get ADHD patterns and insights
   */
  async getPatterns() {
    return this.makeRequest("/api/patterns");
  }
  /**
   * Safe wrapper for API calls with user feedback
   */
  async safeApiCall(operation, fallback, errorMessage) {
    try {
      return await operation();
    } catch (error) {
      console.error("API call failed:", error);
      const message = errorMessage || "API request failed. Please check your connection and backend server.";
      new import_obsidian.Notice(`\u26A0\uFE0F ${message}`, 5e3);
      if (fallback !== void 0) {
        return fallback;
      }
      return void 0;
    }
  }
  /**
   * Convert task breakdown response to format expected by UI
   */
  static formatBreakdownForUI(response) {
    if (!response.success || !response.data) {
      throw new Error("Invalid breakdown response");
    }
    const { data } = response;
    return {
      motivation: `Great choice! I've broken this down into ${data.microTasks.length} manageable steps. \u{1F3AF}`,
      steps: data.microTasks.map((task, index) => ({
        id: task.id || `step_${index}`,
        title: task.title,
        description: task.description,
        estimatedMinutes: task.estimatedMinutes || 20,
        complexity: task.complexity || "simple",
        tips: task.motivationBooster ? [task.motivationBooster] : [],
        energyRequired: task.energyRequired || "moderate",
        executiveFunctionDemands: task.executiveFunctionDemands || [],
        tools: task.tools || [],
        completionCriteria: task.completionCriteria || "Step completed"
      })),
      totalEstimatedTime: data.totalEstimatedTime,
      strategy: data.breakdownStrategy,
      optimizations: data.adhdOptimizations
    };
  }
};

// src/proactive-view.ts
var VIEW_TYPE_PROACTIVITY = "proactivity-view";
var ProactivityView = class extends import_obsidian2.ItemView {
  constructor(leaf, settings, integrationService) {
    super(leaf);
    this.currentEnergyLevel = "moderate";
    this.todaysTasks = [];
    this.currentFocus = "";
    this.settings = settings;
    this.integrationService = integrationService;
    this.apiClient = new ProactivityApiClient(settings);
  }
  getViewType() {
    return VIEW_TYPE_PROACTIVITY;
  }
  getDisplayText() {
    return "Proactivity";
  }
  getIcon() {
    return "brain-circuit";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("proactivity-view");
    this.renderMainInterface(container);
    await this.loadTodaysTasks();
  }
  async onClose() {
  }
  renderMainInterface(container) {
    const header = container.createEl("div", { cls: "proactive-header" });
    const title = header.createEl("h2", { text: "Proactivity Assistant" });
    this.renderEnergySection(container);
    this.renderFocusSection(container);
    this.renderTaskSuggestionsSection(container);
    this.renderProgressSection(container);
    this.renderQuickActionsSection(container);
    this.renderADHDSupportSection(container);
  }
  renderEnergySection(container) {
    const energySection = container.createEl("div", { cls: "energy-section" });
    energySection.createEl("h3", { text: "\u26A1 Energy Level" });
    const energyDisplay = energySection.createEl("div", { cls: "energy-display" });
    const energyLevels = [
      { level: "high", emoji: "\u26A1", label: "High" },
      { level: "moderate", emoji: "\u{1F50B}", label: "Moderate" },
      { level: "low", emoji: "\u{1FAAB}", label: "Low" },
      { level: "depleted", emoji: "\u{1F634}", label: "Depleted" }
    ];
    energyLevels.forEach(({ level, emoji, label }) => {
      const button = energyDisplay.createEl("button", {
        cls: `energy-button ${this.currentEnergyLevel === level ? "active" : ""}`,
        text: `${emoji} ${label}`
      });
      button.onclick = async () => {
        await this.updateEnergyLevel(level);
        this.refreshEnergyDisplay();
      };
    });
    const recommendations = energySection.createEl("div", { cls: "energy-recommendations" });
    this.updateEnergyRecommendations(recommendations);
  }
  renderFocusSection(container) {
    const focusSection = container.createEl("div", { cls: "focus-section" });
    focusSection.createEl("h3", { text: "\u{1F3AF} Current Focus" });
    const focusInput = focusSection.createEl("input", {
      type: "text",
      placeholder: "What are you working on right now?",
      value: this.currentFocus,
      cls: "focus-input"
    });
    focusInput.addEventListener("change", (e) => {
      this.currentFocus = e.target.value;
      this.integrationService.updateCurrentFocus(this.currentFocus);
    });
    const timerSection = focusSection.createEl("div", { cls: "focus-timer" });
    const startButton = timerSection.createEl("button", {
      text: "\u25B6\uFE0F Start 25min Focus",
      cls: "mod-cta"
    });
    startButton.onclick = () => {
      this.startFocusTimer(25);
    };
  }
  renderTaskSuggestionsSection(container) {
    const tasksSection = container.createEl("div", { cls: "tasks-section" });
    tasksSection.createEl("h3", { text: "\u{1F4DD} Smart Task Suggestions" });
    const tasksContainer = tasksSection.createEl("div", { cls: "tasks-container" });
    const refreshButton = tasksSection.createEl("button", {
      text: "\u{1F504} Get New Suggestions",
      cls: "refresh-tasks-btn"
    });
    refreshButton.onclick = () => {
      this.refreshTaskSuggestions();
    };
    this.renderTaskList(tasksContainer);
  }
  renderProgressSection(container) {
    const progressSection = container.createEl("div", { cls: "progress-section" });
    progressSection.createEl("h3", { text: "\u{1F4CA} Today's Progress" });
    const progressBar = progressSection.createEl("div", { cls: "progress-bar" });
    const progressFill = progressBar.createEl("div", { cls: "progress-fill" });
    const stats = progressSection.createEl("div", { cls: "progress-stats" });
    stats.createEl("div", { cls: "stat-item", text: "\u{1F3AF} 0 tasks completed" });
    stats.createEl("div", { cls: "stat-item", text: "\u23F1\uFE0F 0 minutes focused" });
    stats.createEl("div", { cls: "stat-item", text: "\u{1F4DD} 0 words written" });
    const celebrateButton = progressSection.createEl("button", {
      text: "\u{1F389} Celebrate Progress",
      cls: "celebrate-btn"
    });
    celebrateButton.onclick = () => {
      this.celebrateProgress();
    };
  }
  renderQuickActionsSection(container) {
    const actionsSection = container.createEl("div", { cls: "quick-actions-section" });
    actionsSection.createEl("h3", { text: "\u26A1 Quick Actions" });
    const actionsGrid = actionsSection.createEl("div", { cls: "actions-grid" });
    const actions = [
      {
        icon: "\u{1F528}",
        text: "Break Down Task",
        action: () => this.openTaskBreakdown()
      },
      {
        icon: "\u{1F91D}",
        text: "Body Doubling",
        action: () => this.startBodyDoubling()
      },
      {
        icon: "\u{1F9D8}",
        text: "Quick Breathing",
        action: () => this.startBreathingExercise()
      },
      {
        icon: "\u{1F4DD}",
        text: "Quick Note",
        action: () => this.createQuickNote()
      },
      {
        icon: "\u{1F3B2}",
        text: "Random Task",
        action: () => this.getRandomTask()
      },
      {
        icon: "\u{1F4A1}",
        text: "Motivation Boost",
        action: () => this.getMotivationBoost()
      }
    ];
    actions.forEach(({ icon, text, action }) => {
      const button = actionsGrid.createEl("button", {
        cls: "action-button",
        text: `${icon} ${text}`
      });
      button.onclick = action;
    });
  }
  renderADHDSupportSection(container) {
    const supportSection = container.createEl("div", { cls: "adhd-support-section" });
    supportSection.createEl("h3", { text: "\u{1F9E0} ADHD Support" });
    const patternsDiv = supportSection.createEl("div", { cls: "patterns-display" });
    patternsDiv.createEl("p", { text: "No patterns detected yet. I'll learn your rhythms over time." });
    const supportTools = supportSection.createEl("div", { cls: "support-tools" });
    const tools = [
      {
        name: "Procrastination Help",
        icon: "\u{1F198}",
        action: () => this.triggerProcrastinationHelp()
      },
      {
        name: "Time Anchor",
        icon: "\u23F0",
        action: () => this.showTimeAnchor()
      },
      {
        name: "Overwhelm Reset",
        icon: "\u{1F504}",
        action: () => this.overwhelmReset()
      }
    ];
    tools.forEach(({ name, icon, action }) => {
      const toolButton = supportTools.createEl("button", {
        cls: "support-tool-btn",
        text: `${icon} ${name}`
      });
      toolButton.onclick = action;
    });
  }
  // Event handlers and actions
  async updateEnergyLevel(level) {
    this.currentEnergyLevel = level;
    await this.integrationService.updateEnergyLevel(level);
    await this.refreshTaskSuggestions();
    this.updateEnergyRecommendations();
  }
  refreshEnergyDisplay() {
    const energyButtons = this.containerEl.querySelectorAll(".energy-button");
    energyButtons.forEach((button, index) => {
      const levels = ["high", "moderate", "low", "depleted"];
      button.removeClass("active");
      if (levels[index] === this.currentEnergyLevel) {
        button.addClass("active");
      }
    });
  }
  updateEnergyRecommendations(container) {
    if (!container) {
      container = this.containerEl.querySelector(".energy-recommendations");
    }
    if (!container)
      return;
    container.empty();
    const recommendations = this.getEnergyBasedRecommendations();
    recommendations.forEach((rec) => {
      const recEl = container.createEl("div", {
        cls: "energy-recommendation",
        text: `\u{1F4A1} ${rec}`
      });
    });
  }
  getEnergyBasedRecommendations() {
    switch (this.currentEnergyLevel) {
      case "high":
        return [
          "Perfect time for complex writing or analysis",
          "Consider tackling that difficult section",
          "Great for creative brainstorming"
        ];
      case "moderate":
        return [
          "Good for steady writing progress",
          "Ideal for reviewing and editing",
          "Try organizing your notes"
        ];
      case "low":
        return [
          "Perfect for simple, routine tasks",
          "Try reading and highlighting",
          "Organize files or references"
        ];
      case "depleted":
        return [
          "Time for rest and self-care",
          "Light tasks like email checking",
          "Consider a short break or nap"
        ];
      default:
        return ["Update your energy level for personalized suggestions"];
    }
  }
  async refreshTaskSuggestions() {
    const suggestions = await this.integrationService.getTaskSuggestions(this.currentEnergyLevel);
    const container = this.containerEl.querySelector(".tasks-container");
    if (container) {
      this.renderTaskList(container, suggestions);
    }
  }
  renderTaskList(container, tasks) {
    container.empty();
    const tasksToShow = tasks || this.getDefaultTasks();
    if (tasksToShow.length === 0) {
      container.createEl("p", {
        text: "No tasks available. Try breaking down a larger goal!",
        cls: "no-tasks-message"
      });
      return;
    }
    tasksToShow.forEach((task, index) => {
      const taskEl = container.createEl("div", { cls: "task-item" });
      const taskHeader = taskEl.createEl("div", { cls: "task-header" });
      taskHeader.createEl("span", { cls: "task-title", text: task.title });
      taskHeader.createEl("span", { cls: "task-time", text: `\u23F1\uFE0F ${task.estimatedMinutes}min` });
      if (task.description) {
        taskEl.createEl("p", { cls: "task-description", text: task.description });
      }
      const taskActions = taskEl.createEl("div", { cls: "task-actions" });
      const startButton = taskActions.createEl("button", {
        text: "\u25B6\uFE0F Start",
        cls: "task-start-btn"
      });
      startButton.onclick = () => this.startTask(task);
      const breakdownButton = taskActions.createEl("button", {
        text: "\u{1F528} Break Down",
        cls: "task-breakdown-btn"
      });
      breakdownButton.onclick = () => this.breakdownTask(task);
    });
  }
  getDefaultTasks() {
    return [
      {
        id: "default-1",
        title: "Review today's writing goals",
        description: "Quick 5-minute check of what you want to accomplish",
        estimatedMinutes: 5,
        complexity: "micro"
      },
      {
        id: "default-2",
        title: "Organize one reference",
        description: "Add one paper to your reference manager",
        estimatedMinutes: 10,
        complexity: "simple"
      },
      {
        id: "default-3",
        title: "Write one paragraph",
        description: "Draft one paragraph for any section",
        estimatedMinutes: 15,
        complexity: "simple"
      }
    ];
  }
  startFocusTimer(minutes) {
    console.log(`Starting ${minutes} minute focus timer`);
  }
  async startTask(task) {
    this.currentFocus = task.title;
    await this.integrationService.startTask(task);
    const focusInput = this.containerEl.querySelector(".focus-input");
    if (focusInput) {
      focusInput.value = this.currentFocus;
    }
  }
  async breakdownTask(task) {
    console.log("Breaking down task:", task);
  }
  openTaskBreakdown() {
    console.log("Opening task breakdown");
  }
  startBodyDoubling() {
    console.log("Starting body doubling");
  }
  startBreathingExercise() {
    const modal = new BreathingModal(this.app);
    modal.open();
  }
  createQuickNote() {
    this.integrationService.createQuickNote();
  }
  getRandomTask() {
    const randomTasks = this.getDefaultTasks();
    const randomTask = randomTasks[Math.floor(Math.random() * randomTasks.length)];
    this.startTask(randomTask);
  }
  getMotivationBoost() {
    const motivations = [
      "You're doing important work! \u{1F31F}",
      "Every word counts toward your goal! \u{1F4DD}",
      "Your ADHD brain brings unique insights! \u{1F9E0}",
      "Progress over perfection! \u{1F4AA}",
      "You've overcome challenges before! \u{1F3AF}"
    ];
    const motivation = motivations[Math.floor(Math.random() * motivations.length)];
    new import_obsidian2.Notice(motivation);
  }
  triggerProcrastinationHelp() {
    console.log("Triggering procrastination help");
  }
  showTimeAnchor() {
    const now = new Date();
    const timeString = now.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    new import_obsidian2.Notice(`\u{1F550} Time anchor: It's currently ${timeString}`);
  }
  overwhelmReset() {
    console.log("Overwhelm reset triggered");
  }
  celebrateProgress() {
    console.log("Celebrating progress");
  }
  async loadTodaysTasks() {
    this.todaysTasks = await this.integrationService.getTodaysTasks();
  }
};
var BreathingModal = class extends import_obsidian2.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "\u{1F9D8} Quick Breathing Exercise" });
    const instructions = contentEl.createEl("div", { cls: "breathing-instructions" });
    instructions.createEl("p", { text: "Follow along with this simple breathing pattern:" });
    const breathingPattern = contentEl.createEl("div", { cls: "breathing-pattern" });
    const breathingCircle = breathingPattern.createEl("div", { cls: "breathing-circle" });
    const instructionText = contentEl.createEl("p", {
      cls: "breathing-instruction",
      text: "Get ready..."
    });
    this.startBreathingSequence(instructionText, breathingCircle);
    const closeButton = contentEl.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    closeButton.onclick = () => this.close();
  }
  startBreathingSequence(instructionEl, circleEl) {
    const sequence = [
      { text: "Breathe in...", duration: 4e3, action: "expand" },
      { text: "Hold...", duration: 2e3, action: "hold" },
      { text: "Breathe out...", duration: 6e3, action: "contract" },
      { text: "Pause...", duration: 2e3, action: "hold" }
    ];
    let cycleCount = 0;
    const maxCycles = 3;
    const runCycle = () => {
      if (cycleCount >= maxCycles) {
        instructionEl.textContent = "Great job! You're centered and ready to focus. \u{1F31F}";
        return;
      }
      let stepIndex = 0;
      const runStep = () => {
        if (stepIndex >= sequence.length) {
          cycleCount++;
          setTimeout(runCycle, 500);
          return;
        }
        const step = sequence[stepIndex];
        instructionEl.textContent = step.text;
        circleEl.removeClass("expand", "contract");
        if (step.action === "expand") {
          circleEl.addClass("expand");
        } else if (step.action === "contract") {
          circleEl.addClass("contract");
        }
        stepIndex++;
        setTimeout(runStep, step.duration);
      };
      runStep();
    };
    setTimeout(runCycle, 1e3);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/task-breakdown-modal.ts
var import_obsidian3 = require("obsidian");
var TaskBreakdownModal = class extends import_obsidian3.Modal {
  constructor(app, settings, integrationService, sourceFile) {
    super(app);
    this.selectedText = "";
    this.isProcessing = false;
    this.settings = settings;
    this.integrationService = integrationService;
    this.apiClient = new ProactivityApiClient(settings);
    this.sourceFile = sourceFile || null;
  }
  async onOpen() {
    var _a;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("proactive-task-breakdown-modal");
    this.selectedText = await this.integrationService.getSelectedText() || "";
    this.createHeader();
    this.createTaskInputSection();
    this.createContextSection();
    this.createOptionsSection();
    this.createActionButtons();
    this.createBreakdownDisplay();
    if (this.selectedText) {
      this.taskInput.value = `Work on: "${this.selectedText.substring(0, 100)}..."`;
      this.contextInput.value = `Selected text from ${((_a = this.sourceFile) == null ? void 0 : _a.name) || "current file"}`;
    } else if (this.sourceFile) {
      this.taskInput.value = `Continue work on ${this.sourceFile.name}`;
      this.contextInput.value = `Working on file: ${this.sourceFile.path}`;
    }
  }
  createHeader() {
    const { contentEl } = this;
    const header = contentEl.createEl("div", { cls: "modal-header" });
    header.createEl("h2", { text: "\u{1F528} AI Task Breakdown" });
    header.createEl("p", {
      text: "Break down overwhelming tasks into ADHD-friendly micro-steps",
      cls: "modal-subtitle"
    });
  }
  createTaskInputSection() {
    const { contentEl } = this;
    const section = contentEl.createEl("div", { cls: "input-section" });
    section.createEl("label", { text: "What do you want to work on?" });
    this.taskInput = section.createEl("input", {
      type: "text",
      placeholder: 'e.g., "Write the methodology section" or "Analyze survey data"',
      cls: "task-input"
    });
    const suggestions = section.createEl("div", { cls: "quick-suggestions" });
    suggestions.createEl("span", { text: "Quick suggestions: " });
    const suggestionItems = [
      "Write one paragraph",
      "Review one paper",
      "Organize notes",
      "Plan next section"
    ];
    suggestionItems.forEach((suggestion) => {
      const button = suggestions.createEl("button", {
        text: suggestion,
        cls: "suggestion-btn"
      });
      button.onclick = () => {
        this.taskInput.value = suggestion;
      };
    });
  }
  createContextSection() {
    const { contentEl } = this;
    const section = contentEl.createEl("div", { cls: "input-section" });
    section.createEl("label", { text: "Additional context (optional)" });
    this.contextInput = section.createEl("textarea", {
      placeholder: "Any relevant details, constraints, or background information...",
      cls: "context-input"
    });
  }
  createOptionsSection() {
    const { contentEl } = this;
    const section = contentEl.createEl("div", { cls: "options-section" });
    const depthContainer = section.createEl("div", { cls: "option-container" });
    depthContainer.createEl("label", { text: "Breakdown detail level" });
    this.depthSlider = depthContainer.createEl("input", {
      type: "range",
      cls: "depth-slider"
    });
    this.depthSlider.min = "1";
    this.depthSlider.max = "5";
    this.depthSlider.value = this.settings.defaultBreakdownDepth.toString();
    const depthLabel = depthContainer.createEl("span", {
      text: this.getDepthLabel(this.settings.defaultBreakdownDepth),
      cls: "depth-label"
    });
    this.depthSlider.oninput = () => {
      const depth = parseInt(this.depthSlider.value);
      depthLabel.textContent = this.getDepthLabel(depth);
    };
    const energyContainer = section.createEl("div", { cls: "option-container" });
    energyContainer.createEl("label", { text: "Your current energy level" });
    this.energySelect = energyContainer.createEl("select", { cls: "energy-select" });
    const energyOptions = [
      { value: "high", text: "\u26A1 High - Ready for complex tasks" },
      { value: "moderate", text: "\u{1F50B} Moderate - Normal capacity" },
      { value: "low", text: "\u{1FAAB} Low - Simple tasks only" },
      { value: "depleted", text: "\u{1F634} Depleted - Need rest/micro-tasks" }
    ];
    energyOptions.forEach((option) => {
      const optionEl = this.energySelect.createEl("option", {
        value: option.value,
        text: option.text
      });
      if (option.value === "moderate") {
        optionEl.selected = true;
      }
    });
    const timeContainer = section.createEl("div", { cls: "option-container" });
    timeContainer.createEl("label", { text: "Available time (minutes)" });
    this.timeInput = timeContainer.createEl("input", {
      type: "number",
      cls: "time-input"
    });
    this.timeInput.min = "5";
    this.timeInput.max = "180";
    this.timeInput.value = "30";
  }
  createActionButtons() {
    const { contentEl } = this;
    const buttonContainer = contentEl.createEl("div", { cls: "button-container" });
    const breakdownBtn = buttonContainer.createEl("button", {
      text: "\u{1F916} Break Down Task",
      cls: "mod-cta breakdown-btn"
    });
    breakdownBtn.onclick = () => this.performBreakdown();
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "cancel-btn"
    });
    cancelBtn.onclick = () => this.close();
  }
  createBreakdownDisplay() {
    const { contentEl } = this;
    this.breakdownContainer = contentEl.createEl("div", { cls: "breakdown-container" });
  }
  getDepthLabel(depth) {
    const labels = {
      1: "Basic (2-3 steps)",
      2: "Simple (3-5 steps)",
      3: "Detailed (5-8 steps)",
      4: "Very Detailed (8-12 steps)",
      5: "Micro-steps (12+ steps)"
    };
    return labels[depth] || "Detailed";
  }
  async performBreakdown() {
    var _a;
    if (this.isProcessing)
      return;
    const task = this.taskInput.value.trim();
    if (!task) {
      new import_obsidian3.Notice("Please enter a task to break down");
      return;
    }
    this.isProcessing = true;
    this.showProcessingState();
    try {
      const breakdown = await this.requestTaskBreakdown({
        task,
        context: this.contextInput.value.trim(),
        depth: parseInt(this.depthSlider.value),
        energyLevel: this.energySelect.value,
        availableTime: parseInt(this.timeInput.value),
        sourceFile: (_a = this.sourceFile) == null ? void 0 : _a.path,
        selectedText: this.selectedText
      });
      this.displayBreakdown(breakdown);
    } catch (error) {
      console.error("Task breakdown error:", error);
      this.showError("Failed to break down task. Please try again.");
    } finally {
      this.isProcessing = false;
    }
  }
  showProcessingState() {
    this.breakdownContainer.empty();
    this.breakdownContainer.addClass("processing");
    const processing = this.breakdownContainer.createEl("div", { cls: "processing-message" });
    processing.createEl("div", { cls: "spinner" });
    processing.createEl("p", { text: "\u{1F916} Breaking down your task into ADHD-friendly steps..." });
    processing.createEl("p", {
      text: "This usually takes 10-15 seconds",
      cls: "processing-subtitle"
    });
  }
  showError(message) {
    this.breakdownContainer.empty();
    this.breakdownContainer.removeClass("processing");
    const error = this.breakdownContainer.createEl("div", { cls: "error-message" });
    error.createEl("p", { text: "\u274C " + message });
    const retryBtn = error.createEl("button", {
      text: "Try Again",
      cls: "retry-btn"
    });
    retryBtn.onclick = () => this.performBreakdown();
  }
  displayBreakdown(breakdown) {
    this.breakdownContainer.empty();
    this.breakdownContainer.removeClass("processing");
    if (!breakdown || !breakdown.steps || breakdown.steps.length === 0) {
      this.showError("No breakdown steps received");
      return;
    }
    const header = this.breakdownContainer.createEl("div", { cls: "breakdown-header" });
    header.createEl("h3", { text: "\u2728 Your ADHD-Friendly Task Breakdown" });
    if (breakdown.motivation) {
      header.createEl("p", {
        text: breakdown.motivation,
        cls: "motivation-message"
      });
    }
    const stepsList = this.breakdownContainer.createEl("div", { cls: "steps-list" });
    breakdown.steps.forEach((step, index) => {
      const stepEl = stepsList.createEl("div", { cls: "breakdown-step" });
      const stepHeader = stepEl.createEl("div", { cls: "step-header" });
      stepHeader.createEl("span", {
        text: `${index + 1}.`,
        cls: "step-number"
      });
      stepHeader.createEl("h4", {
        text: step.title,
        cls: "step-title"
      });
      stepHeader.createEl("span", {
        text: `\u23F1\uFE0F ${step.estimatedMinutes}min`,
        cls: "step-time"
      });
      if (step.description) {
        stepEl.createEl("p", {
          text: step.description,
          cls: "step-description"
        });
      }
      if (step.tips && step.tips.length > 0) {
        const tipsList = stepEl.createEl("ul", { cls: "step-tips" });
        step.tips.forEach((tip) => {
          tipsList.createEl("li", { text: tip });
        });
      }
      const stepActions = stepEl.createEl("div", { cls: "step-actions" });
      const startBtn = stepActions.createEl("button", {
        text: "\u25B6\uFE0F Start",
        cls: "step-start-btn"
      });
      startBtn.onclick = () => this.startStep(step);
      const addToVaultBtn = stepActions.createEl("button", {
        text: "\u{1F4DD} Add to Daily Note",
        cls: "step-add-btn"
      });
      addToVaultBtn.onclick = () => this.addStepToVault(step);
    });
    const footer = this.breakdownContainer.createEl("div", { cls: "breakdown-footer" });
    const addAllBtn = footer.createEl("button", {
      text: "\u{1F4CB} Add All Steps to Daily Note",
      cls: "mod-cta"
    });
    addAllBtn.onclick = () => this.addAllStepsToVault(breakdown.steps);
    const newBreakdownBtn = footer.createEl("button", {
      text: "\u{1F504} Try Different Breakdown",
      cls: "secondary-btn"
    });
    newBreakdownBtn.onclick = () => {
      this.breakdownContainer.empty();
    };
  }
  async requestTaskBreakdown(params) {
    const request = {
      task: params.task,
      context: {
        currentEnergyLevel: params.energyLevel,
        availableTime: params.availableTime,
        preferredComplexity: this.getComplexityFromDepth(params.depth),
        executiveFunctionChallenges: [],
        currentProject: "dissertation",
        sourceFile: params.sourceFile,
        selectedText: params.selectedText,
        depth: params.depth
      }
    };
    try {
      const isConnected = await this.apiClient.testConnection();
      if (!isConnected) {
        throw new Error("Unable to connect to Proactivity backend. Using fallback breakdown.");
      }
      const response = await this.apiClient.breakdownTask(request);
      return ProactivityApiClient.formatBreakdownForUI(response);
    } catch (error) {
      console.warn("API breakdown failed, using fallback:", error);
      new import_obsidian3.Notice("Using local breakdown (backend unavailable)", 4e3);
      return this.getFallbackBreakdown(params);
    }
  }
  getComplexityFromDepth(depth) {
    const complexityMap = {
      1: "micro",
      2: "simple",
      3: "moderate",
      4: "moderate",
      5: "complex"
    };
    return complexityMap[depth] || "moderate";
  }
  getFallbackBreakdown(params) {
    const stepCount = Math.max(2, Math.min(8, params.depth + 1));
    const timePerStep = Math.floor(params.availableTime / stepCount);
    const fallbackSteps = [
      {
        id: `fallback_${Date.now()}_1`,
        title: "Clarify the goal",
        description: `Define exactly what you want to accomplish with: "${params.task}"`,
        estimatedMinutes: Math.min(10, timePerStep),
        complexity: "micro",
        tips: ["Write down the specific outcome you want", "Break it into concrete terms"]
      },
      {
        id: `fallback_${Date.now()}_2`,
        title: "Gather materials",
        description: "Collect all documents, tools, or resources you'll need",
        estimatedMinutes: Math.min(15, timePerStep),
        complexity: "simple",
        tips: ["Have everything within reach", "Close distracting tabs/apps"]
      },
      {
        id: `fallback_${Date.now()}_3`,
        title: "Start with the easiest part",
        description: "Begin with the most straightforward aspect of this task",
        estimatedMinutes: timePerStep,
        complexity: "simple",
        tips: ["Momentum builds with action", "Perfect is the enemy of done"]
      }
    ];
    if (stepCount > 3) {
      fallbackSteps.push({
        id: `fallback_${Date.now()}_4`,
        title: "Make steady progress",
        description: "Continue working on the main content of your task",
        estimatedMinutes: timePerStep,
        complexity: "moderate",
        tips: ["Take breaks if you need them", "Celebrate small wins"]
      });
    }
    if (stepCount > 4) {
      fallbackSteps.push({
        id: `fallback_${Date.now()}_5`,
        title: "Review and refine",
        description: "Look over what you've accomplished and make improvements",
        estimatedMinutes: Math.min(20, timePerStep),
        complexity: "simple",
        tips: ["Focus on progress over perfection", "You've done great work!"]
      });
    }
    return {
      motivation: `I've created a ${stepCount}-step breakdown to help you tackle this task. You've got this! \u{1F3AF}`,
      steps: fallbackSteps.slice(0, stepCount),
      totalEstimatedTime: fallbackSteps.slice(0, stepCount).reduce((sum, step) => sum + step.estimatedMinutes, 0),
      strategy: "fallback-breakdown",
      optimizations: ["momentum-building", "adhd-friendly-steps"]
    };
  }
  async startStep(step) {
    await this.integrationService.startTask({
      title: step.title,
      description: step.description,
      estimatedMinutes: step.estimatedMinutes,
      complexity: step.complexity
    });
    new import_obsidian3.Notice(`Started: ${step.title} (${step.estimatedMinutes}min)`);
    this.close();
  }
  async addStepToVault(step) {
    const dailyNotePath = await this.getDailyNotePath();
    if (!dailyNotePath) {
      new import_obsidian3.Notice("Unable to find daily note");
      return;
    }
    try {
      const file = await this.getOrCreateFile(dailyNotePath);
      const content = await this.app.vault.read(file);
      const taskEntry = `- [ ] ${step.title} (${step.estimatedMinutes}min)${step.description ? ` - ${step.description}` : ""}
`;
      const updatedContent = this.updateTasksSection(content, taskEntry);
      await this.app.vault.modify(file, updatedContent);
      new import_obsidian3.Notice(`Added "${step.title}" to daily note`);
    } catch (error) {
      console.error("Error adding step to vault:", error);
      new import_obsidian3.Notice("Error adding step to daily note");
    }
  }
  async addAllStepsToVault(steps) {
    const dailyNotePath = await this.getDailyNotePath();
    if (!dailyNotePath) {
      new import_obsidian3.Notice("Unable to find daily note");
      return;
    }
    try {
      const file = await this.getOrCreateFile(dailyNotePath);
      const content = await this.app.vault.read(file);
      const taskEntries = steps.map(
        (step) => `- [ ] ${step.title} (${step.estimatedMinutes}min)${step.description ? ` - ${step.description}` : ""}`
      ).join("\n") + "\n";
      const updatedContent = this.updateTasksSection(content, taskEntries);
      await this.app.vault.modify(file, updatedContent);
      new import_obsidian3.Notice(`Added ${steps.length} tasks to daily note`);
      this.close();
    } catch (error) {
      console.error("Error adding steps to vault:", error);
      new import_obsidian3.Notice("Error adding tasks to daily note");
    }
  }
  async getDailyNotePath() {
    const today = new Date().toISOString().split("T")[0];
    const dailyNoteFolder = this.settings.obsidianIntegration.dailyNotePath;
    return `${dailyNoteFolder}/${today}.md`;
  }
  async getOrCreateFile(path) {
    let file = this.app.vault.getAbstractFileByPath(path);
    if (!file) {
      const template = this.createDailyNoteTemplate();
      file = await this.app.vault.create(path, template);
    }
    return file;
  }
  createDailyNoteTemplate() {
    const today = new Date().toLocaleDateString();
    return `# Daily Note - ${today}

${this.settings.obsidianIntegration.taskTagPrefix}/daily-note

## Energy Tracking

## Current Focus

## Tasks

## Progress

## Celebrations

## Reflections

---
*Generated by Proactivity*`;
  }
  updateTasksSection(content, newTasks) {
    const tasksSection = "## Tasks";
    const sectionRegex = new RegExp(`(${tasksSection}\\n)[\\s\\S]*?(?=\\n## |\\n---|$)`, "i");
    if (sectionRegex.test(content)) {
      return content.replace(sectionRegex, `${tasksSection}

${newTasks}`);
    } else {
      const dividerIndex = content.lastIndexOf("\n---");
      if (dividerIndex !== -1) {
        return content.slice(0, dividerIndex) + `
${tasksSection}

${newTasks}
` + content.slice(dividerIndex);
      } else {
        return content + `

${tasksSection}

${newTasks}`;
      }
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/adhd-pattern-detector.ts
var import_obsidian4 = require("obsidian");
var ADHDPatternDetector = class {
  constructor(app, settings) {
    this.activityHistory = [];
    this.currentSession = null;
    this.detectionInterval = null;
    this.lastFileActivity = Date.now();
    this.currentFile = null;
    this.consecutiveFileSwitches = 0;
    this.hyperfocusStartTime = null;
    this.isDetectionActive = false;
    this.app = app;
    this.settings = settings;
    this.setupEventListeners();
  }
  startDetection() {
    if (this.isDetectionActive)
      return;
    this.isDetectionActive = true;
    this.startNewSession();
    this.detectionInterval = setInterval(() => {
      this.analyzePatterns();
    }, 5 * 60 * 1e3);
    console.log("ADHD pattern detection started");
  }
  stopDetection() {
    if (!this.isDetectionActive)
      return;
    this.isDetectionActive = false;
    if (this.detectionInterval) {
      clearInterval(this.detectionInterval);
      this.detectionInterval = null;
    }
    this.endCurrentSession();
    console.log("ADHD pattern detection stopped");
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  getCurrentPatterns() {
    return this.analyzeCurrentBehavior();
  }
  checkFocusState() {
    if (!this.isDetectionActive)
      return;
    const now = Date.now();
    const inactiveMinutes = (now - this.lastFileActivity) / (1e3 * 60);
    if (this.hyperfocusStartTime) {
      const hyperfocusDuration = (now - this.hyperfocusStartTime) / (1e3 * 60);
      if (hyperfocusDuration > 90 && this.settings.enableHyperfocusProtection) {
        this.triggerHyperfocusWarning(hyperfocusDuration);
      }
    }
    if (inactiveMinutes > this.settings.procrastinationThreshold) {
      this.triggerProcrastinationDetection(inactiveMinutes);
    }
  }
  setupEventListeners() {
    this.app.workspace.on("file-open", (file) => {
      this.recordActivity("file_open", { file: file == null ? void 0 : file.path });
      this.handleFileActivity((file == null ? void 0 : file.path) || null);
    });
    this.app.vault.on("modify", (file) => {
      this.recordActivity("file_edit", { file: file.path });
      this.handleFileActivity(file.path);
    });
    this.app.workspace.on("active-leaf-change", () => {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile && activeFile.path !== this.currentFile) {
        this.handleFileSwitch(activeFile.path);
      }
    });
  }
  handleFileActivity(filePath) {
    const now = Date.now();
    const timeSinceLastActivity = now - this.lastFileActivity;
    this.lastFileActivity = now;
    if (timeSinceLastActivity < 5 * 60 * 1e3) {
      if (!this.hyperfocusStartTime) {
        this.hyperfocusStartTime = now;
      }
    } else {
      this.hyperfocusStartTime = null;
    }
    if (this.currentSession) {
      this.currentSession.activities.push({
        timestamp: now,
        type: "file_edit",
        data: { file: filePath }
      });
    }
  }
  handleFileSwitch(newFilePath) {
    if (this.currentFile && this.currentFile !== newFilePath) {
      this.consecutiveFileSwitches++;
      this.recordActivity("file_switch", {
        from: this.currentFile,
        to: newFilePath,
        consecutiveSwitches: this.consecutiveFileSwitches
      });
      if (this.consecutiveFileSwitches > 5) {
        this.triggerTaskSwitchingDetection();
      }
    } else {
      this.consecutiveFileSwitches = 0;
    }
    this.currentFile = newFilePath;
  }
  recordActivity(type, data) {
    const event = {
      timestamp: Date.now(),
      type,
      data
    };
    this.activityHistory.push(event);
    const cutoff = Date.now() - 24 * 60 * 60 * 1e3;
    this.activityHistory = this.activityHistory.filter((event2) => event2.timestamp > cutoff);
  }
  startNewSession() {
    this.endCurrentSession();
    this.currentSession = {
      startTime: Date.now(),
      activities: [],
      focusScore: 0,
      tasksCompleted: 0,
      filesModified: 0
    };
  }
  endCurrentSession() {
    if (this.currentSession) {
      this.currentSession.endTime = Date.now();
      this.calculateSessionMetrics();
    }
  }
  calculateSessionMetrics() {
    if (!this.currentSession)
      return;
    const session = this.currentSession;
    const duration = (session.endTime || Date.now()) - session.startTime;
    const activityGaps = this.calculateActivityGaps(session.activities);
    session.focusScore = this.calculateFocusScore(activityGaps, duration);
    session.filesModified = session.activities.filter((a) => a.type === "file_edit").length;
  }
  calculateActivityGaps(activities) {
    const gaps = [];
    for (let i = 1; i < activities.length; i++) {
      gaps.push(activities[i].timestamp - activities[i - 1].timestamp);
    }
    return gaps;
  }
  calculateFocusScore(gaps, duration) {
    if (gaps.length === 0)
      return 0;
    const averageGap = gaps.reduce((sum, gap) => sum + gap, 0) / gaps.length;
    const maxGap = Math.max(...gaps);
    const consistencyScore = 1 - (maxGap - averageGap) / duration;
    const activityScore = Math.min(gaps.length / (duration / (10 * 60 * 1e3)), 1);
    return Math.max(0, Math.min(1, (consistencyScore + activityScore) / 2));
  }
  analyzePatterns() {
    const patterns = [];
    patterns.push(...this.detectProcrastinationPattern());
    patterns.push(...this.detectHyperfocusPattern());
    patterns.push(...this.detectTaskSwitchingPattern());
    patterns.push(...this.detectEnergyPattern());
    patterns.push(...this.detectProductiveTimePattern());
    return patterns;
  }
  analyzeCurrentBehavior() {
    return this.analyzePatterns();
  }
  detectProcrastinationPattern() {
    const now = Date.now();
    const recentActivity = this.activityHistory.filter(
      (event) => now - event.timestamp < 60 * 60 * 1e3
      // Last hour
    );
    if (recentActivity.length < 3) {
      const inactiveMinutes = (now - this.lastFileActivity) / (1e3 * 60);
      if (inactiveMinutes > this.settings.procrastinationThreshold) {
        return [{
          type: "procrastination",
          confidence: Math.min(0.9, inactiveMinutes / 60),
          description: `Low activity detected for ${Math.round(inactiveMinutes)} minutes`,
          suggestions: [
            "Try the 2-minute rule: commit to just 2 minutes of work",
            "Break your task into smaller micro-steps",
            "Use the Pomodoro technique with shorter intervals",
            "Consider if this is the right energy level for this task"
          ],
          healthConcern: false,
          detected: now
        }];
      }
    }
    return [];
  }
  detectHyperfocusPattern() {
    if (!this.hyperfocusStartTime)
      return [];
    const now = Date.now();
    const hyperfocusDuration = (now - this.hyperfocusStartTime) / (1e3 * 60);
    if (hyperfocusDuration > 60) {
      return [{
        type: "hyperfocus",
        confidence: Math.min(0.9, hyperfocusDuration / 120),
        description: `Sustained focus session: ${Math.round(hyperfocusDuration)} minutes`,
        suggestions: [
          "Great focus! Consider taking a 5-10 minute break soon",
          "Hydrate and stretch to maintain this energy",
          "Set a gentle reminder to check in with your body",
          "Remember to eat if it's been a while"
        ],
        healthConcern: hyperfocusDuration > 120,
        // Health concern after 2 hours
        detected: now
      }];
    }
    return [];
  }
  detectTaskSwitchingPattern() {
    const recentSwitches = this.activityHistory.filter(
      (event) => event.type === "file_switch" && Date.now() - event.timestamp < 30 * 60 * 1e3
      // Last 30 minutes
    );
    if (recentSwitches.length > 8) {
      return [{
        type: "task_switching",
        confidence: Math.min(0.9, recentSwitches.length / 15),
        description: `High task switching: ${recentSwitches.length} file changes in 30 minutes`,
        suggestions: [
          "You seem to be jumping between tasks - this is totally normal with ADHD!",
          "Try closing extra tabs to reduce visual distractions",
          "Pick one file to focus on for the next 15 minutes",
          "Consider if you need a break or different type of task"
        ],
        healthConcern: false,
        detected: Date.now()
      }];
    }
    return [];
  }
  detectEnergyPattern() {
    return [];
  }
  detectProductiveTimePattern() {
    if (!this.currentSession)
      return [];
    const sessionDuration = (Date.now() - this.currentSession.startTime) / (1e3 * 60);
    if (sessionDuration > 25 && this.currentSession.focusScore > 0.7) {
      return [{
        type: "productive_time",
        confidence: this.currentSession.focusScore,
        description: `High productivity session: ${Math.round(sessionDuration)} minutes`,
        suggestions: [
          "You're in a great flow state!",
          "Your ADHD brain is working well right now",
          "Consider what factors are helping you focus today",
          "Remember this pattern for future reference"
        ],
        healthConcern: false,
        detected: Date.now()
      }];
    }
    return [];
  }
  triggerHyperfocusWarning(duration) {
    if (!this.settings.enableHyperfocusProtection)
      return;
    const hours = Math.floor(duration / 60);
    const minutes = Math.round(duration % 60);
    new import_obsidian4.Notice(
      `\u{1F499} Hyperfocus check-in: You've been focused for ${hours}h ${minutes}m. Consider a gentle break for your wellbeing.`,
      8e3
    );
  }
  triggerProcrastinationDetection(inactiveMinutes) {
    const roundedMinutes = Math.round(inactiveMinutes);
    new import_obsidian4.Notice(
      `\u{1F917} Gentle nudge: It's been ${roundedMinutes} minutes since your last activity. No judgment - want to try a tiny step?`,
      6e3
    );
  }
  triggerTaskSwitchingDetection() {
    new import_obsidian4.Notice(
      `\u{1F9E0} I notice you're switching between tasks frequently - totally normal with ADHD! Maybe try focusing on one file for 10 minutes?`,
      7e3
    );
    this.consecutiveFileSwitches = 0;
  }
  // Public methods for external use
  recordEnergyUpdate(energyLevel) {
    this.recordActivity("energy_update", { energyLevel });
  }
  recordTaskStart(task) {
    this.recordActivity("task_start", { task });
    if (this.currentSession) {
      this.currentSession.tasksCompleted++;
    }
  }
  recordTaskComplete(task) {
    this.recordActivity("task_complete", { task });
  }
  getSessionSummary() {
    if (!this.currentSession)
      return null;
    const duration = (Date.now() - this.currentSession.startTime) / (1e3 * 60);
    return {
      duration: Math.round(duration),
      focusScore: this.currentSession.focusScore,
      tasksCompleted: this.currentSession.tasksCompleted,
      filesModified: this.currentSession.filesModified,
      patterns: this.getCurrentPatterns()
    };
  }
  exportPatternData() {
    return {
      activityHistory: this.activityHistory,
      currentSession: this.currentSession,
      detectedPatterns: this.getCurrentPatterns(),
      metadata: {
        detectionActive: this.isDetectionActive,
        settingsSnapshot: this.settings
      }
    };
  }
};

// src/obsidian-integration-service.ts
var import_obsidian5 = require("obsidian");
var ObsidianIntegrationService = class {
  constructor(app, settings) {
    this.dailyNotificationCount = 0;
    this.lastNotificationReset = "";
    this.app = app;
    this.settings = settings;
    this.apiClient = new ProactivityApiClient(settings);
    this.resetDailyCountIfNeeded();
  }
  updateSettings(settings) {
    this.settings = settings;
    this.apiClient.updateSettings(settings);
  }
  /**
   * Get current context from Obsidian environment
   */
  async getCurrentContext() {
    const activeFile = this.app.workspace.getActiveFile();
    const openFiles = this.app.workspace.getLeavesOfType("markdown").length;
    const selectedText = await this.getSelectedText();
    return {
      activeFile: (activeFile == null ? void 0 : activeFile.name) || null,
      activeFilePath: (activeFile == null ? void 0 : activeFile.path) || null,
      openFiles,
      selectedText,
      hasUnfinishedTasks: await this.hasUnfinishedTasks(),
      energyLevel: await this.getCurrentEnergyLevel(),
      inactiveForMinutes: this.getInactivityMinutes(),
      currentWorkingDirectory: this.getCurrentWorkingDirectory(),
      recentActivity: await this.getRecentActivity()
    };
  }
  /**
   * Get selected text from the active editor
   */
  async getSelectedText() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!activeView)
      return null;
    const editor = activeView.editor;
    return editor.getSelection() || null;
  }
  /**
   * Create a quick note for capturing thoughts
   */
  async createQuickNote() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const noteName = `Quick Note ${timestamp}`;
    const notePath = `${this.settings.obsidianIntegration.dailyNotePath}/${noteName}.md`;
    const noteContent = `# Quick Note

Created: ${new Date().toLocaleString()}
Tags: ${this.settings.obsidianIntegration.taskTagPrefix}/quick-note

## Thoughts

<!-- Write your thoughts here -->

## Next Actions

<!-- What do you want to do with this idea? -->

---
*Created with Proactivity*`;
    try {
      const file = await this.app.vault.create(notePath, noteContent);
      await this.app.workspace.getLeaf().openFile(file);
      new import_obsidian5.Notice("Quick note created! Start writing your thoughts.");
    } catch (error) {
      console.error("Error creating quick note:", error);
      new import_obsidian5.Notice("Error creating quick note. Check your settings.");
    }
  }
  /**
   * Update user's current energy level
   */
  async updateEnergyLevel(energyLevel) {
    const dailyNotePath = await this.getDailyNotePath();
    if (dailyNotePath) {
      try {
        const file = await this.getOrCreateFile(dailyNotePath);
        const content = await this.app.vault.read(file);
        const energySection = `
## Energy Tracking

- ${new Date().toLocaleTimeString()}: ${energyLevel}
`;
        const updatedContent = this.updateDailyNoteSection(content, "Energy Tracking", energySection);
        await this.app.vault.modify(file, updatedContent);
      } catch (error) {
        console.error("Error updating energy level locally:", error);
      }
    }
    await this.apiClient.safeApiCall(
      () => this.apiClient.updateEnergyLevel(energyLevel),
      void 0,
      "Failed to sync energy level with backend"
    );
  }
  /**
   * Update current focus/task
   */
  async updateCurrentFocus(focus) {
    const dailyNotePath = await this.getDailyNotePath();
    if (!dailyNotePath)
      return;
    try {
      const file = await this.getOrCreateFile(dailyNotePath);
      const content = await this.app.vault.read(file);
      const focusSection = `
## Current Focus

${focus}

Started: ${new Date().toLocaleTimeString()}
`;
      const updatedContent = this.updateDailyNoteSection(content, "Current Focus", focusSection);
      await this.app.vault.modify(file, updatedContent);
    } catch (error) {
      console.error("Error updating current focus:", error);
    }
  }
  /**
   * Start tracking a task
   */
  async startTask(task) {
    const dailyNotePath = await this.getDailyNotePath();
    if (dailyNotePath) {
      try {
        const file = await this.getOrCreateFile(dailyNotePath);
        const content = await this.app.vault.read(file);
        const taskEntry = `- [ ] ${task.title} (${task.estimatedMinutes}min) - Started: ${new Date().toLocaleTimeString()}
`;
        const updatedContent = this.updateDailyNoteSection(content, "Tasks", `
## Tasks

${taskEntry}`);
        await this.app.vault.modify(file, updatedContent);
        new import_obsidian5.Notice(`Started: ${task.title}`);
      } catch (error) {
        console.error("Error starting task locally:", error);
      }
    }
    await this.apiClient.safeApiCall(
      () => this.apiClient.startTask(task.id || `task_${Date.now()}`, task.estimatedMinutes),
      void 0,
      "Failed to sync task start with backend"
    );
    await this.apiClient.safeApiCall(
      () => this.apiClient.recordActivity("task_start", {
        taskId: task.id,
        title: task.title,
        estimatedMinutes: task.estimatedMinutes,
        complexity: task.complexity
      })
    );
  }
  /**
   * Get task suggestions based on current context and energy level
   */
  async getTaskSuggestions(energyLevel) {
    const context = await this.getCurrentContext();
    const backendSuggestions = await this.apiClient.safeApiCall(
      () => this.apiClient.getTaskSuggestions(energyLevel, 30),
      null,
      "Using local task suggestions"
    );
    if (backendSuggestions == null ? void 0 : backendSuggestions.success) {
      return backendSuggestions.data;
    }
    return this.getLocalTaskSuggestions(energyLevel, context);
  }
  async getLocalTaskSuggestions(energyLevel, context) {
    const dissertationFiles = await this.getDissertationFiles();
    const unfinishedTasks = await this.getUnfinishedTasks();
    const suggestions = [];
    switch (energyLevel) {
      case "high":
        suggestions.push(
          {
            title: "Draft a new section",
            description: "Use your high energy for creative writing",
            estimatedMinutes: 45,
            complexity: "complex",
            source: "energy-based"
          },
          {
            title: "Analyze complex data",
            description: "Perfect time for analytical work",
            estimatedMinutes: 60,
            complexity: "complex",
            source: "energy-based"
          }
        );
        break;
      case "moderate":
        suggestions.push(
          {
            title: "Edit existing content",
            description: "Review and improve what you've written",
            estimatedMinutes: 30,
            complexity: "moderate",
            source: "energy-based"
          },
          {
            title: "Organize references",
            description: "Structure your research materials",
            estimatedMinutes: 25,
            complexity: "simple",
            source: "energy-based"
          }
        );
        break;
      case "low":
        suggestions.push(
          {
            title: "Read one paper",
            description: "Light reading and note-taking",
            estimatedMinutes: 20,
            complexity: "simple",
            source: "energy-based"
          },
          {
            title: "Update citation format",
            description: "Simple formatting tasks",
            estimatedMinutes: 15,
            complexity: "micro",
            source: "energy-based"
          }
        );
        break;
      case "depleted":
        suggestions.push(
          {
            title: "Review tomorrow's goals",
            description: "Quick planning for when you're refreshed",
            estimatedMinutes: 10,
            complexity: "micro",
            source: "energy-based"
          }
        );
        break;
    }
    if (context.activeFile && context.activeFile.includes(".md")) {
      suggestions.push({
        title: `Continue work on ${context.activeFile}`,
        description: "Build on your current file",
        estimatedMinutes: 20,
        complexity: "moderate",
        source: "context-based"
      });
    }
    if (context.selectedText) {
      suggestions.push({
        title: "Expand selected text",
        description: "Develop the highlighted section further",
        estimatedMinutes: 15,
        complexity: "simple",
        source: "context-based"
      });
    }
    suggestions.push(...unfinishedTasks.slice(0, 2));
    return suggestions.slice(0, 5).map((task, index) => ({
      ...task,
      id: task.id || `suggestion_${Date.now()}_${index}`,
      adhdOptimized: true
    }));
  }
  /**
   * Get today's tasks from daily note
   */
  async getTodaysTasks() {
    const dailyNotePath = await this.getDailyNotePath();
    if (!dailyNotePath)
      return [];
    try {
      const file = this.app.vault.getAbstractFileByPath(dailyNotePath);
      if (!file || !(file instanceof import_obsidian5.TFile))
        return [];
      const content = await this.app.vault.read(file);
      return this.extractTasksFromContent(content);
    } catch (error) {
      console.error("Error getting today's tasks:", error);
      return [];
    }
  }
  /**
   * Check if there are unfinished tasks
   */
  async hasUnfinishedTasks() {
    const tasks = await this.getTodaysTasks();
    return tasks.some((task) => !task.completed);
  }
  /**
   * Get unfinished tasks
   */
  async getUnfinishedTasks() {
    const tasks = await this.getTodaysTasks();
    return tasks.filter((task) => !task.completed).map((task) => ({
      ...task,
      source: "existing-task"
    }));
  }
  /**
   * Log progress celebration for pattern recognition
   */
  async logProgressCelebration() {
    const dailyNotePath = await this.getDailyNotePath();
    if (!dailyNotePath)
      return;
    try {
      const file = await this.getOrCreateFile(dailyNotePath);
      const content = await this.app.vault.read(file);
      const celebrationEntry = `
\u{1F389} Progress celebrated at ${new Date().toLocaleTimeString()}
`;
      const updatedContent = this.updateDailyNoteSection(content, "Celebrations", `
## Celebrations
${celebrationEntry}`);
      await this.app.vault.modify(file, updatedContent);
    } catch (error) {
      console.error("Error logging celebration:", error);
    }
  }
  /**
   * Get recent notification count
   */
  getRecentNotificationCount() {
    this.resetDailyCountIfNeeded();
    return this.dailyNotificationCount;
  }
  /**
   * Increment notification count
   */
  incrementNotificationCount() {
    this.resetDailyCountIfNeeded();
    this.dailyNotificationCount++;
  }
  /**
   * Get user activity metrics
   */
  async getUserActivity() {
    const recentActivity = await this.getRecentActivity();
    const lastActivity = recentActivity[0];
    const inactiveMinutes = lastActivity ? Math.floor((Date.now() - lastActivity.timestamp) / (1e3 * 60)) : 120;
    return {
      inactiveForMinutes: inactiveMinutes,
      seemsStuck: inactiveMinutes > 30 && inactiveMinutes < 120,
      recentFileChanges: recentActivity.length,
      lastActivity: (lastActivity == null ? void 0 : lastActivity.action) || "unknown"
    };
  }
  // Private helper methods
  async getDailyNotePath() {
    const today = new Date().toISOString().split("T")[0];
    const dailyNoteFolder = this.settings.obsidianIntegration.dailyNotePath;
    return `${dailyNoteFolder}/${today}.md`;
  }
  async getOrCreateFile(path) {
    let file = this.app.vault.getAbstractFileByPath(path);
    if (!file) {
      const template = this.createDailyNoteTemplate();
      file = await this.app.vault.create(path, template);
    }
    return file;
  }
  createDailyNoteTemplate() {
    const today = new Date().toLocaleDateString();
    return `# Daily Note - ${today}

${this.settings.obsidianIntegration.taskTagPrefix}/daily-note

## Energy Tracking

## Current Focus

## Tasks

## Progress

## Celebrations

## Reflections

---
*Generated by Proactivity*`;
  }
  updateDailyNoteSection(content, sectionName, newSection) {
    const sectionRegex = new RegExp(`(## ${sectionName}\\n)[\\s\\S]*?(?=\\n## |\\n---|$)`, "i");
    if (sectionRegex.test(content)) {
      return content.replace(sectionRegex, newSection);
    } else {
      const dividerIndex = content.lastIndexOf("\n---");
      if (dividerIndex !== -1) {
        return content.slice(0, dividerIndex) + newSection + "\n" + content.slice(dividerIndex);
      } else {
        return content + "\n" + newSection;
      }
    }
  }
  extractTasksFromContent(content) {
    const taskRegex = /^- \[([ x])\] (.+)$/gm;
    const tasks = [];
    let match;
    while ((match = taskRegex.exec(content)) !== null) {
      const completed = match[1] === "x";
      const title = match[2];
      const timeMatch = title.match(/\((\d+)min\)/);
      const estimatedMinutes = timeMatch ? parseInt(timeMatch[1]) : 30;
      tasks.push({
        title: title.replace(/\s*\(\d+min\).*$/, ""),
        completed,
        estimatedMinutes,
        complexity: estimatedMinutes <= 15 ? "micro" : estimatedMinutes <= 30 ? "simple" : "moderate"
      });
    }
    return tasks;
  }
  async getDissertationFiles() {
    const dissertationPath = this.settings.obsidianIntegration.dissertationFolderPath;
    const folder = this.app.vault.getAbstractFileByPath(dissertationPath);
    if (!folder || !(folder instanceof import_obsidian5.TFolder))
      return [];
    return folder.children.filter((file) => file instanceof import_obsidian5.TFile && file.extension === "md");
  }
  getCurrentWorkingDirectory() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return "";
    const pathParts = activeFile.path.split("/");
    return pathParts.slice(0, -1).join("/");
  }
  async getRecentActivity() {
    return [
      {
        timestamp: Date.now() - 10 * 60 * 1e3,
        // 10 minutes ago
        action: "file_modified",
        file: "Chapter 3.md"
      }
    ];
  }
  async getCurrentEnergyLevel() {
    return "moderate";
  }
  getInactivityMinutes() {
    return 25;
  }
  resetDailyCountIfNeeded() {
    const today = new Date().toDateString();
    if (this.lastNotificationReset !== today) {
      this.dailyNotificationCount = 0;
      this.lastNotificationReset = today;
    }
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  apiKey: "",
  serverUrl: "http://localhost:3002",
  enableProactiveNotifications: true,
  maxDailyNotifications: 12,
  defaultBreakdownDepth: 3,
  enablePatternDetection: true,
  enableHyperfocusProtection: true,
  procrastinationThreshold: 30,
  energyCheckInterval: 120,
  obsidianIntegration: {
    enableTaskSync: true,
    enableProgressTracking: true,
    enableSmartLinking: true,
    dissertationFolderPath: "Dissertation",
    dailyNotePath: "Daily Notes",
    taskTagPrefix: "#proactivity"
  },
  adhdSupport: {
    useGentleTone: true,
    includeMotivation: true,
    limitCognitiveLoad: true,
    enableBodyDoubling: false,
    timeBlindnessSupport: true
  }
};
var ProactivityPlugin = class extends import_obsidian6.Plugin {
  async onload() {
    await this.loadSettings();
    this.integrationService = new ObsidianIntegrationService(this.app, this.settings);
    this.patternDetector = new ADHDPatternDetector(this.app, this.settings);
    await this.testBackendConnection();
    this.registerView(
      VIEW_TYPE_PROACTIVITY,
      (leaf) => new ProactivityView(leaf, this.settings, this.integrationService)
    );
    this.addRibbonIcon("brain-circuit", "Proactivity", () => {
      this.activateView();
    });
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBar("Ready");
    this.registerCommands();
    if (this.settings.enablePatternDetection) {
      this.patternDetector.startDetection();
    }
    if (this.settings.enableProactiveNotifications) {
      this.startProactiveNotifications();
    }
    this.addSettingTab(new ProactivitySettingTab(this.app, this));
    new import_obsidian6.Notice("Proactivity: Your ADHD-friendly dissertation assistant is ready!");
  }
  async testBackendConnection() {
    try {
      const response = await fetch(`${this.settings.serverUrl}/health`);
      if (response.ok) {
        const health = await response.json();
        new import_obsidian6.Notice(`\u2705 Connected to Proactivity backend (v${health.version || "1.0.0"})`, 3e3);
        this.updateStatusBar("Connected");
      } else {
        throw new Error("Backend health check failed");
      }
    } catch (error) {
      console.warn("Backend connection failed:", error);
      new import_obsidian6.Notice("\u26A0\uFE0F Backend offline - using local mode. Task breakdown will use fallback.", 6e3);
      this.updateStatusBar("Offline mode");
    }
  }
  onunload() {
    var _a;
    if (this.notificationInterval) {
      clearInterval(this.notificationInterval);
    }
    (_a = this.patternDetector) == null ? void 0 : _a.stopDetection();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    var _a, _b;
    await this.saveData(this.settings);
    (_a = this.integrationService) == null ? void 0 : _a.updateSettings(this.settings);
    (_b = this.patternDetector) == null ? void 0 : _b.updateSettings(this.settings);
  }
  registerCommands() {
    this.addCommand({
      id: "breakdown-current-task",
      name: "Break down current task",
      callback: () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          this.openTaskBreakdownModal(activeFile);
        } else {
          new import_obsidian6.Notice("Please open a file or select text to break down");
        }
      }
    });
    this.addCommand({
      id: "energy-check",
      name: "Quick energy level check",
      callback: () => {
        this.showEnergyCheckModal();
      }
    });
    this.addCommand({
      id: "start-focus-session",
      name: "Start focused work session",
      callback: () => {
        this.startFocusSession();
      }
    });
    this.addCommand({
      id: "procrastination-help",
      name: "Help! I'm procrastinating",
      callback: () => {
        this.triggerProcrastinationIntervention();
      }
    });
    this.addCommand({
      id: "celebrate-progress",
      name: "Celebrate progress made",
      callback: () => {
        this.celebrateProgress();
      }
    });
    this.addCommand({
      id: "vacation-mode",
      name: "Start vacation mode",
      callback: () => {
        new import_obsidian6.Notice("Vacation mode activated. Enjoy your break! \u{1F3D6}\uFE0F");
      }
    });
    this.addCommand({
      id: "deep-focus-mode",
      name: "Start deep focus mode",
      callback: () => {
        new import_obsidian6.Notice("Deep focus mode activated. \u{1F3AF}");
      }
    });
    this.addCommand({
      id: "end-out-of-office",
      name: "End out of office mode",
      callback: () => {
        new import_obsidian6.Notice("Welcome back! All features restored. \u2728");
      }
    });
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_PROACTIVITY);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: VIEW_TYPE_PROACTIVITY, active: true }));
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  openTaskBreakdownModal(file) {
    const modal = new TaskBreakdownModal(
      this.app,
      this.settings,
      this.integrationService,
      file
    );
    modal.open();
  }
  showEnergyCheckModal() {
    const modal = new class extends import_obsidian6.Modal {
      constructor(app, plugin) {
        super(app);
        this.plugin = plugin;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.createEl("h2", { text: "Energy Level Check" });
        const description = contentEl.createEl("p", {
          text: "How's your energy and focus right now? This helps me suggest appropriate tasks."
        });
        const energyLevels = [
          { level: "high", label: "\u26A1 High - Ready for complex tasks", color: "#22c55e" },
          { level: "moderate", label: "\u{1F50B} Moderate - Normal capacity", color: "#3b82f6" },
          { level: "low", label: "\u{1FAAB} Low - Simple tasks only", color: "#f59e0b" },
          { level: "depleted", label: "\u{1F634} Depleted - Need rest/micro-tasks", color: "#ef4444" }
        ];
        energyLevels.forEach(({ level, label, color }) => {
          const button = contentEl.createEl("button", {
            text: label,
            cls: "mod-cta energy-level-button"
          });
          button.style.backgroundColor = color;
          button.style.margin = "10px 0";
          button.style.width = "100%";
          button.onclick = async () => {
            await this.plugin.handleEnergyLevelUpdate(level);
            this.close();
          };
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app, this);
    modal.open();
  }
  async handleEnergyLevelUpdate(energyLevel) {
    this.updateStatusBar(`Energy: ${energyLevel}`);
    await this.integrationService.updateEnergyLevel(energyLevel);
    const suggestions = await this.integrationService.getTaskSuggestions(energyLevel);
    if (suggestions && suggestions.length > 0) {
      new import_obsidian6.Notice(`Based on your ${energyLevel} energy, I suggest: ${suggestions[0].title}`);
    }
  }
  startFocusSession() {
    const sessionLength = 25;
    new import_obsidian6.Notice(`Starting ${sessionLength}-minute focus session. I'll check in periodically.`);
    this.updateStatusBar("\u{1F3AF} Focusing");
    const checkInInterval = setInterval(() => {
      this.patternDetector.checkFocusState();
    }, 10 * 60 * 1e3);
    setTimeout(() => {
      clearInterval(checkInInterval);
      new import_obsidian6.Notice("Focus session complete! Great job. Time for a break?");
      this.updateStatusBar("\u2705 Session done");
    }, sessionLength * 60 * 1e3);
  }
  async triggerProcrastinationIntervention() {
    new import_obsidian6.Notice("I'm here to help! Let's break through this together.");
    const activeFile = this.app.workspace.getActiveFile();
    const selectedText = await this.integrationService.getSelectedText();
    this.openTaskBreakdownModal(activeFile);
    this.updateStatusBar("\u{1F91D} Body doubling active");
  }
  celebrateProgress() {
    const celebrations = [
      "\u{1F389} Amazing work! Every step counts.",
      "\u{1F44F} You're making real progress!",
      "\u2B50 Your persistence is paying off!",
      "\u{1F680} Look at you, crushing it!",
      "\u{1F4AA} Your ADHD brain is powerful!"
    ];
    const celebration = celebrations[Math.floor(Math.random() * celebrations.length)];
    new import_obsidian6.Notice(celebration);
    this.integrationService.logProgressCelebration();
  }
  startProactiveNotifications() {
    this.notificationInterval = setInterval(async () => {
      const shouldNotify = await this.shouldSendProactiveNotification();
      if (shouldNotify) {
        await this.sendContextualNotification();
      }
    }, this.settings.energyCheckInterval * 60 * 1e3);
  }
  async shouldSendProactiveNotification() {
    const patterns = await this.patternDetector.getCurrentPatterns();
    const isInHyperfocus = patterns.some((p) => p.type === "hyperfocus");
    const userActivity = await this.integrationService.getUserActivity();
    if (isInHyperfocus) {
      return patterns.some((p) => p.healthConcern);
    }
    const recentNotifications = this.integrationService.getRecentNotificationCount();
    if (recentNotifications >= 3) {
      return false;
    }
    return userActivity.seemsStuck || userActivity.inactiveForMinutes > 45;
  }
  async sendContextualNotification() {
    const context = await this.integrationService.getCurrentContext();
    const notification = await this.generateContextualNotification(context);
    if (notification) {
      new import_obsidian6.Notice(notification.message);
      if (notification.action) {
        setTimeout(() => {
          this[notification.action]();
        }, 5e3);
      }
    }
  }
  async generateContextualNotification(context) {
    if (context.hasUnfinishedTasks && context.energyLevel !== "depleted") {
      return {
        message: "I noticed some tasks in progress. Want to tackle one together?",
        action: "activateView"
      };
    }
    if (context.inactiveForMinutes > 60) {
      return {
        message: "How's your dissertation work going today? Any goals you'd like to set?",
        action: "showEnergyCheckModal"
      };
    }
    return null;
  }
  updateStatusBar(status) {
    this.statusBarItem.setText(`Proactivity: ${status}`);
  }
};
var ProactivitySettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Proactivity Settings" });
    containerEl.createEl("h3", { text: "API Configuration" });
    new import_obsidian6.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for AI-powered task breakdown").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Server URL").setDesc("Proactivity backend server URL").addText((text) => text.setPlaceholder("http://localhost:3001").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
      this.plugin.settings.serverUrl = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "ADHD Support Features" });
    new import_obsidian6.Setting(containerEl).setName("Enable Proactive Notifications").setDesc("Receive gentle, context-aware notifications and check-ins").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableProactiveNotifications).onChange(async (value) => {
      this.plugin.settings.enableProactiveNotifications = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Enable Pattern Detection").setDesc("Detect ADHD patterns like procrastination and hyperfocus").addToggle((toggle) => toggle.setValue(this.plugin.settings.enablePatternDetection).onChange(async (value) => {
      this.plugin.settings.enablePatternDetection = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Enable Hyperfocus Protection").setDesc("Get gentle reminders during extended work sessions").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableHyperfocusProtection).onChange(async (value) => {
      this.plugin.settings.enableHyperfocusProtection = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Max Daily Notifications").setDesc("Limit notifications to prevent overwhelm").addSlider((slider) => slider.setLimits(3, 20, 1).setValue(this.plugin.settings.maxDailyNotifications).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxDailyNotifications = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Obsidian Integration" });
    new import_obsidian6.Setting(containerEl).setName("Dissertation Folder Path").setDesc("Path to your dissertation notes folder").addText((text) => text.setPlaceholder("Dissertation").setValue(this.plugin.settings.obsidianIntegration.dissertationFolderPath).onChange(async (value) => {
      this.plugin.settings.obsidianIntegration.dissertationFolderPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Enable Smart Linking").setDesc("Automatically create connections between related notes").addToggle((toggle) => toggle.setValue(this.plugin.settings.obsidianIntegration.enableSmartLinking).onChange(async (value) => {
      this.plugin.settings.obsidianIntegration.enableSmartLinking = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Enable Progress Tracking").setDesc("Track your writing progress and patterns").addToggle((toggle) => toggle.setValue(this.plugin.settings.obsidianIntegration.enableProgressTracking).onChange(async (value) => {
      this.plugin.settings.obsidianIntegration.enableProgressTracking = value;
      await this.plugin.saveSettings();
    }));
  }
};
